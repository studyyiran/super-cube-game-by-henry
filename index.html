<!DOCTYPE html>
<html lang="zh">


<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>对战游戏</title>
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=GA_MEASUREMENT_ID"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        
        // 请将 GA_MEASUREMENT_ID 替换为您的实际 Google Analytics 测量 ID
        gtag('config', 'GA_MEASUREMENT_ID');
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.2) 0%, transparent 50%),
                linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #533483 100%);
            background-size: 400% 400%, 400% 400%, 400% 400%, 100% 100%;
            animation: cosmicShift 12s ease infinite;
            position: relative;
        }
        
        @keyframes cosmicShift {
            0%, 100% { 
                background-position: 0% 50%, 100% 50%, 50% 0%, center;
                filter: hue-rotate(0deg);
            }
            25% { 
                background-position: 100% 50%, 0% 50%, 0% 100%, center;
                filter: hue-rotate(90deg);
            }
            50% { 
                background-position: 50% 100%, 50% 0%, 100% 50%, center;
                filter: hue-rotate(180deg);
            }
            75% { 
                background-position: 0% 0%, 100% 100%, 50% 50%, center;
                filter: hue-rotate(270deg);
            }
        }
        
        /* 炫酷粒子背景系统 */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            border-radius: 50%;
            animation: cosmicFloat 8s ease-in-out infinite;
        }
        
        .particle.neon {
            background: radial-gradient(circle, #00ffff 0%, transparent 70%);
            box-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
        }
        
        .particle.plasma {
            background: radial-gradient(circle, #ff00ff 0%, transparent 70%);
            box-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff, 0 0 60px #ff00ff;
        }
        
        .particle.energy {
            background: radial-gradient(circle, #ffff00 0%, transparent 70%);
            box-shadow: 0 0 20px #ffff00, 0 0 40px #ffff00, 0 0 60px #ffff00;
        }
        
        @keyframes cosmicFloat {
            0% { 
                transform: translateY(100vh) translateX(0px) rotate(0deg) scale(0);
                opacity: 0;
            }
            10% { 
                opacity: 1;
                transform: translateY(90vh) translateX(10px) rotate(36deg) scale(1);
            }
            50% { 
                opacity: 1;
                transform: translateY(50vh) translateX(-20px) rotate(180deg) scale(1.2);
            }
            90% { 
                opacity: 1;
                transform: translateY(10vh) translateX(30px) rotate(324deg) scale(0.8);
            }
            100% { 
                transform: translateY(-10vh) translateX(0px) rotate(360deg) scale(0);
                opacity: 0;
            }
        }
        
        /* 霓虹灯边框效果 */
        .neon-border {
            position: relative;
        }
        
        .neon-border::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            border-radius: inherit;
            z-index: -1;
            animation: neonRotate 3s linear infinite;
        }
        
        @keyframes neonRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #gameCanvas {
            border: 3px solid #00ffff;
            background: transparent;
            width: 100%;
            height: 100%;
            filter: blur(5px); /* 初始模糊效果 */
            transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 
                0 0 30px #00ffff,
                0 0 60px #00ffff,
                inset 0 0 30px rgba(0, 255, 255, 0.1);
            border-radius: 10px;
            position: relative;
        }
        
        #gameCanvas::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            border-radius: 15px;
            z-index: -1;
            animation: neonRotate 4s linear infinite;
            opacity: 0.7;
        }
        
        #gameCanvas.game-active {
            filter: none;
            box-shadow: 
                0 0 50px #00ffff,
                0 0 100px #00ffff,
                0 0 150px #00ffff,
                inset 0 0 50px rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
        }
        
        #welcomeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: 
                radial-gradient(circle at 30% 70%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 30%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at center, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.95) 100%);
            backdrop-filter: blur(15px);
            z-index: 100;
            animation: fadeInScale 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            overflow: hidden;
            border: 1px solid rgba(0, 255, 255, 0.2);
            box-shadow: 
                inset 0 0 50px rgba(0, 255, 255, 0.1),
                inset 0 0 100px rgba(255, 0, 255, 0.1);
        }
        
        #welcomeScreen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(45deg, transparent 30%, rgba(0, 255, 255, 0.03) 50%, transparent 70%),
                linear-gradient(-45deg, transparent 30%, rgba(255, 0, 255, 0.03) 50%, transparent 70%);
            animation: scanLines 4s linear infinite;
            pointer-events: none;
        }
        
        @keyframes scanLines {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* 动态画布背景 */
        #dynamicCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }
        
        /* 动态几何图形样式已移除 */
        

        
        @keyframes fadeInScale {
            0% { opacity: 0; transform: scale(0.9); }
            100% { opacity: 1; transform: scale(1); }
        }
        
        #welcomeMessage {
            color: #ffffff;
            font-size: 2.5em;
            margin-bottom: 40px;
            text-align: center;
            animation: cyberpunkGlow 3s ease-in-out infinite;
            text-shadow: 
                0 0 10px #00ffff,
                0 0 20px #00ffff,
                0 0 30px #00ffff,
                0 0 40px #ff00ff;
            font-weight: bold;
            letter-spacing: 2px;
            position: relative;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: cyberpunkGlow 3s ease-in-out infinite, gradientText 4s ease infinite;
        }
        
        @keyframes cyberpunkGlow {
            0%, 100% { 
                text-shadow: 
                    0 0 10px #00ffff,
                    0 0 20px #00ffff,
                    0 0 30px #00ffff,
                    0 0 40px #ff00ff;
                transform: scale(1);
            }
            50% { 
                text-shadow: 
                    0 0 20px #00ffff,
                    0 0 30px #00ffff,
                    0 0 40px #00ffff,
                    0 0 50px #ff00ff,
                    0 0 60px #ffff00;
                transform: scale(1.02);
            }
        }
        
        @keyframes gradientText {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .gameButton {
            padding: 15px 30px;
            margin: 10px;
            font-size: 1.2em;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            position: relative;
            overflow: hidden;
        }
        .gameButton:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.6s;
        }
        .gameButton:hover {
            background: linear-gradient(45deg, #2980b9, #1abc9c);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.5);
        }
        .gameButton:hover:before {
            left: 100%;
        }
        .gameButton:active {
            transform: translateY(-1px) scale(1.02);
        }
        
        /* 现代化按钮样式 */
        .modern-button {
            position: relative;
            padding: 15px 25px;
            margin: 8px;
            font-size: 1.1em;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-width: 140px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }
        
        .plaza-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, #00ffff 0%, #0080ff 50%, #004080 100%);
            border: 3px solid #00ffff;
            box-shadow: 
                0 0 20px #00ffff,
                0 0 40px #00ffff,
                inset 0 0 20px rgba(0, 255, 255, 0.2);
            animation: neonPulse 2s ease-in-out infinite alternate;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: unset;
        }
        
        .create-room-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff00ff 0%, #ff0080 50%, #800040 100%);
            border: 3px solid #ff00ff;
            box-shadow: 
                0 0 20px #ff00ff,
                0 0 40px #ff00ff,
                inset 0 0 20px rgba(255, 0, 255, 0.2);
            animation: neonPulse 2s ease-in-out infinite alternate;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: unset;
        }
        
        @keyframes neonPulse {
            0% {
                box-shadow: 
                    0 0 20px currentColor,
                    0 0 40px currentColor,
                    inset 0 0 20px rgba(255, 255, 255, 0.1);
                transform: scale(1);
            }
            100% {
                box-shadow: 
                    0 0 30px currentColor,
                    0 0 60px currentColor,
                    0 0 80px currentColor,
                    inset 0 0 30px rgba(255, 255, 255, 0.2);
                transform: scale(1.05);
            }
        }
        
        .modern-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
        }
        
        .plaza-button:hover {
            background: radial-gradient(circle, #00ffff 0%, #00ccff 30%, #0099ff 70%, #0066cc 100%);
            box-shadow: 
                0 0 40px #00ffff,
                0 0 80px #00ffff,
                0 0 120px #00ffff,
                inset 0 0 30px rgba(0, 255, 255, 0.3);
            transform: translateY(-5px) scale(1.1);
            animation: neonPulse 1s ease-in-out infinite alternate;
        }
        
        .create-room-button:hover {
            background: radial-gradient(circle, #ff00ff 0%, #ff00cc 30%, #ff0099 70%, #cc0066 100%);
            box-shadow: 
                0 0 40px #ff00ff,
                0 0 80px #ff00ff,
                0 0 120px #ff00ff,
                inset 0 0 30px rgba(255, 0, 255, 0.3);
            transform: translateY(-5px) scale(1.1);
            animation: neonPulse 1s ease-in-out infinite alternate;
        }
        
        .modern-button:active {
            transform: translateY(-1px) scale(1.02);
        }
        
        .button-icon {
            font-size: 1.8em;
            animation: iconPulse 2s ease-in-out infinite;
            margin-bottom: 2px;
        }
        
        .button-text {
            font-weight: 600;
            letter-spacing: 0.5px;
            font-size: 0.7em;
            text-align: center;
            line-height: 1;
        }
        
        .plaza-button .button-text,
        .create-room-button .button-text {
            font-size: 0.6em;
            font-weight: 700;
            text-shadow: 0 0 10px currentColor;
        }
        
        .plaza-button .button-icon,
        .create-room-button .button-icon {
            font-size: 1.5em;
            filter: drop-shadow(0 0 8px currentColor);
        }
        
        /* 按钮光圈效果已移除 */
        
        @keyframes iconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        /* 现代化弹窗样式 */
        .modern-modal {
            backdrop-filter: blur(10px);
            animation: modalFadeIn 0.3s ease-out;
        }
        
        .modern-modal-content {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 2px solid rgba(52, 152, 219, 0.6);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.1);
            animation: modalSlideIn 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            overflow: hidden;
        }
        
        .modern-modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3498db, #9b59b6, #e74c3c, #f39c12, #2ecc71);
            background-size: 300% 100%;
            animation: gradientMove 3s ease infinite;
        }
        
        .modern-modal h2, .modern-modal h3 {
            background: linear-gradient(45deg, #3498db, #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.8em;
            text-shadow: none;
        }
        
        .modern-button-primary {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .modern-button-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(39, 174, 96, 0.4);
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
        }
        
        .modern-button-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            border-radius: 12px;
            padding: 12px 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }
        
        .modern-button-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(231, 76, 60, 0.4);
            background: linear-gradient(135deg, #c0392b 0%, #e74c3c 100%);
        }
        
        .modern-input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(52, 152, 219, 0.3);
            border-radius: 10px;
            color: white;
            padding: 12px 15px;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        .modern-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
            background: rgba(255, 255, 255, 0.15);
        }
        
        .room-info-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .room-stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .stat-item {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }
        
        .stat-value {
            color: #3498db;
            font-size: 1.2em;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        @keyframes gradientMove {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* 创建房间弹窗特殊动画 */
        .modern-modal {
            animation: modalFadeIn 0.3s ease-out;
        }
        
        .modern-modal .modern-modal-content {
            animation: modalSlideIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        /* 游戏模式按钮特殊效果 */
        #gameModeModal button[onclick*="selectGameMode"] {
            position: relative;
            overflow: hidden;
        }
        
        #gameModeModal button[onclick*="selectGameMode"]:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
        }
        
        #gameModeModal button[onclick*="selectGameMode"]:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }
        
        #gameModeModal button[onclick*="selectGameMode"]:hover:before {
            left: 100%;
        }
        
        /* 人数选择按钮动画 */
        #playerCountModal button[onclick*="selectPlayerCount"] {
            position: relative;
            overflow: hidden;
        }
        
        #playerCountModal button[onclick*="selectPlayerCount"]:hover {
            transform: scale(1.1) rotate(2deg);
        }
        
        /* 输入框聚焦效果 */
        .modern-input:focus {
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.6);
            border-color: #3498db;
        }
        
        /* 游戏按钮样式 - 恢复原始矩形样式并移到左边 */
        .play-button {
            width: 250px;
            height: 80px;
            border-radius: 12px;
            display: block !important;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            font-size: 1.4em;
            font-weight: bold;
            line-height: 1.2;
            margin: 10px;
            text-align: center;
            position: absolute;
            z-index: 9999 !important;
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            border: 3px solid #2c3e50;
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.3);
            transition: all 0.3s ease;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .play-button:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 20px rgba(52, 152, 219, 0.4);
        }
        
        /* 四个游戏按钮的具体位置 */
        #singlePlayerBtn {
            left: 30px;
            top: 25px;
        }
        
        #multiPlayerBtn {
            left: 30px;
            top: 35px;
        }
        
        #exitBtn {
            left: 30px;
            top: 45px;
        }
        
        #rulesBtn {
            left: 30px;
            top: 55px;
        }
        
        /* 难度按钮特殊样式 */
        .difficulty-easy:hover {
            background: linear-gradient(45deg, #27ae60, #2ecc71) !important;
            transform: translateY(-3px) scale(1.05);
        }
        
        .difficulty-normal:hover {
            background: linear-gradient(45deg, #2980b9, #3498db) !important;
            transform: translateY(-3px) scale(1.05);
        }
        
        .difficulty-hard:hover {
            background: linear-gradient(45deg, #c0392b, #e74c3c) !important;
            transform: translateY(-3px) scale(1.05);
        }
        
        .difficulty-hell:hover {
            background: linear-gradient(45deg, #9b59b6, #8e44ad) !important;
            transform: translateY(-3px) scale(1.05);
        }
        .terrainButton {
            padding: 15px;
            margin: 5px;
            font-size: 1.1em;
            background-color: #ecf0f1;
            color: #2c3e50;
            border: 2px solid #bdc3c7;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .terrainButton:hover {
            background-color: #d5dbdb;
            border-color: #95a5a6;
        }
        .terrainButton.selected {
            background-color: #e8f5e8;
            border-color: #27ae60;
        }
        .terrainButton.selected .terrainIndicator {
            background-color: #27ae60 !important;
        }
        
        /* 建议按钮样式 - 炫酷版 */
        #suggestionButton {
            position: absolute;
            top: 30px;
            left: 120px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 102;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4), 0 0 20px rgba(102, 126, 234, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        #suggestionButton::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.6s;
        }
        
        #suggestionButton:hover {
            background: linear-gradient(45deg, #764ba2 0%, #667eea 100%);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6), 0 0 30px rgba(102, 126, 234, 0.4);
        }
        
        #suggestionButton:hover::before {
            left: 100%;
        }
        
        /* 邮箱按钮样式 - 炫酷版 */
        #mailboxButton {
            position: absolute;
            top: 30px;
            left: 200px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            z-index: 102;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4), 0 0 20px rgba(255, 107, 107, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            animation: mailboxPulse 2s infinite;
        }
        
        @keyframes mailboxPulse {
            0%, 100% { box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4), 0 0 20px rgba(255, 107, 107, 0.2); }
            50% { box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6), 0 0 30px rgba(255, 107, 107, 0.4); }
        }
        
        #mailboxButton::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.6s;
        }
        
        #mailboxButton:hover {
            background: linear-gradient(45deg, #ee5a24 0%, #ff6b6b 100%);
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 40px rgba(255, 107, 107, 0.7), 0 0 40px rgba(255, 107, 107, 0.5);
            animation: none;
        }
        
        #mailboxButton:hover::before {
            left: 100%;
        }
        
        /* 创建房间按钮样式 */
        #createRoomButton {
            position: absolute;
            top: 20px;
            right: 110px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: #9b59b6;
            color: white;
            border: none;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            z-index: 102;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #createRoomButton:hover {
            background-color: #8e44ad;
            transform: scale(1.05);
        }
        
        /* 广场按钮样式 */
        #squareButton {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: #f39c12;
            color: white;
            border: none;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 102;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #squareButton:hover {
            background-color: #e67e22;
            transform: scale(1.05);
        }
        
        /* 未读消息徽章样式 */
        .unread-badge {
            position: absolute;
            top: 22px;
            left: 252px;
            background-color: #f39c12;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
            z-index: 103;
        }
        
        .unread-badge.hidden {
            display: none;
        }
        
        /* 邮箱弹窗样式 - 炫酷版 */
        #mailboxModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.9) 100%);
            backdrop-filter: blur(10px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: modalBackdropFadeIn 0.4s ease-out;
        }
        
        @keyframes modalBackdropFadeIn {
            from { opacity: 0; backdrop-filter: blur(0px); }
            to { opacity: 1; backdrop-filter: blur(10px); }
        }
        
        #mailboxModalContent {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            width: 500px;
            max-height: 600px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5), 0 0 50px rgba(102, 126, 234, 0.3);
            overflow: hidden;
            position: relative;
            animation: mailboxModalSlideIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        @keyframes mailboxModalSlideIn {
            from { transform: translateY(-50px) scale(0.9); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        #mailboxModalContent::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            animation: mailboxShimmer 3s infinite;
        }
        
        @keyframes mailboxShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .mailbox-header {
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.1) 100%);
            backdrop-filter: blur(10px);
            color: white;
            padding: 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            position: relative;
            z-index: 1;
        }
        
        .mailbox-header h2 {
            margin: 0;
            font-size: 22px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
            font-weight: 600;
        }
        
        .close-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 2;
        }
        
        .close-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.5);
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 5px 15px rgba(255,255,255,0.2);
        }
        
        .mailbox-messages {
            max-height: 500px;
            overflow-y: auto;
            padding: 25px;
            background: rgba(255,255,255,0.95);
            position: relative;
            z-index: 1;
        }
        
        .empty-state {
            text-align: center;
            color: #7f8c8d;
            font-size: 16px;
            padding: 40px 20px;
        }
        
        .message-item {
            background: linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.8) 100%);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid transparent;
            background-clip: padding-box;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1), 0 0 20px rgba(102, 126, 234, 0.1);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            overflow: hidden;
        }
        
        .message-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
        }
        
        .message-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15), 0 0 30px rgba(102, 126, 234, 0.2);
        }
        
        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .message-time {
            color: #8e44ad;
            font-size: 11px;
            font-weight: 500;
            background: rgba(142, 68, 173, 0.1);
            padding: 4px 8px;
            border-radius: 12px;
        }
        
        .message-from {
            color: #667eea;
            font-size: 13px;
            font-weight: bold;
            text-shadow: 0 1px 3px rgba(102, 126, 234, 0.3);
        }
        
        .message-content {
            color: #2c3e50;
            line-height: 1.6;
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        .message-dismiss {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .message-dismiss:hover {
            background: linear-gradient(45deg, #764ba2 0%, #667eea 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        /* 建议弹窗样式 - 炫酷版 */
        #suggestionModal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.9) 100%);
            backdrop-filter: blur(10px);
            animation: suggestionBackdropFadeIn 0.4s ease-out;
        }
        
        @keyframes suggestionBackdropFadeIn {
            from { opacity: 0; backdrop-filter: blur(0px); }
            to { opacity: 1; backdrop-filter: blur(10px); }
        }
        
        #suggestionModalContent {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 8% auto;
            padding: 0;
            border: none;
            width: 85%;
            max-width: 550px;
            border-radius: 25px;
            position: relative;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5), 0 0 50px rgba(102, 126, 234, 0.3);
            overflow: hidden;
            animation: suggestionModalSlideIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        
        @keyframes suggestionModalSlideIn {
            from { transform: translateY(-50px) scale(0.9); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }
        
        #suggestionModalContent::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            animation: suggestionShimmer 3s infinite;
            pointer-events: none;
        }
        
        @keyframes suggestionShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        #suggestionModalContent h2 {
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.1) 100%);
            backdrop-filter: blur(10px);
            color: white;
            margin: 0;
            padding: 25px 30px;
            font-size: 24px;
            font-weight: 600;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
            border-bottom: 1px solid rgba(255,255,255,0.2);
            position: relative;
            z-index: 1;
        }
        
        #suggestionModalContent p {
            color: white;
            margin: 0;
            padding: 20px 30px 10px;
            font-size: 16px;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }
        
        #suggestionTextarea {
            width: calc(100% - 60px);
            height: 160px;
            padding: 20px;
            margin: 20px 30px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 15px;
            font-size: 15px;
            resize: vertical;
            box-sizing: border-box;
            background: rgba(255,255,255,0.95);
            color: #2c3e50;
            font-family: inherit;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            backdrop-filter: blur(10px);
            position: relative;
            z-index: 1;
        }
        
        #suggestionTextarea:focus {
            border-color: rgba(255,255,255,0.6);
            outline: none;
            box-shadow: 0 0 20px rgba(255,255,255,0.3), inset 0 0 20px rgba(102, 126, 234, 0.1);
            background: rgba(255,255,255,1);
        }
        
        .suggestionButtons {
            display: flex;
            justify-content: space-between;
            padding: 0 30px 30px;
            gap: 15px;
            position: relative;
            z-index: 1;
        }
        
        .suggestionBtn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .suggestionBtn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.6s;
        }
        
        .suggestionBtn:hover::before {
            left: 100%;
        }
        
        .suggestionBtn.submit {
            background: linear-gradient(45deg, #00b894 0%, #00cec9 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(0, 184, 148, 0.4);
        }
        
        .suggestionBtn.submit:hover {
            background: linear-gradient(45deg, #00cec9 0%, #00b894 100%);
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0, 184, 148, 0.6);
        }
        
        .suggestionBtn.cancel {
            background: linear-gradient(45deg, #636e72 0%, #74b9ff 100%);
            color: white;
            box-shadow: 0 8px 25px rgba(99, 110, 114, 0.4);
        }
        
        .suggestionBtn.cancel:hover {
            background: linear-gradient(45deg, #74b9ff 0%, #636e72 100%);
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(99, 110, 114, 0.6);
        }
        
        /* 建议通知样式 - 炫酷版 */
         #suggestionNotification {
             position: fixed;
             top: 30px;
             right: 30px;
             background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
             color: white;
             padding: 25px;
             border-radius: 20px;
             box-shadow: 0 15px 40px rgba(0, 184, 148, 0.4), 0 0 30px rgba(0, 184, 148, 0.2);
             display: none;
             z-index: 1001;
             max-width: 380px;
             animation: notificationSlideIn 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
             backdrop-filter: blur(10px);
             border: 1px solid rgba(255,255,255,0.2);
             position: relative;
             overflow: hidden;
         }
         
         #suggestionNotification::before {
             content: '';
             position: absolute;
             top: 0;
             left: -100%;
             width: 100%;
             height: 100%;
             background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
             animation: notificationShimmer 2s infinite;
         }
         
         @keyframes notificationShimmer {
             0% { left: -100%; }
             100% { left: 100%; }
         }
         
         #suggestionNotification.show {
             display: block;
             animation: notificationSlideIn 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
         }
         
         @keyframes notificationSlideIn {
             from { 
                 transform: translateX(100%) scale(0.8); 
                 opacity: 0;
                 box-shadow: 0 5px 15px rgba(0, 184, 148, 0.2);
             }
             to { 
                 transform: translateX(0) scale(1); 
                 opacity: 1;
                 box-shadow: 0 15px 40px rgba(0, 184, 148, 0.4), 0 0 30px rgba(0, 184, 148, 0.2);
             }
         }
         
         #suggestionNotification .notification-content {
             display: flex;
             align-items: center;
             justify-content: space-between;
             gap: 15px;
         }
         
         #suggestionNotification .notification-text {
             flex: 1;
         }
         
         /* 开发者通知样式 */
         #developerNotification {
             position: fixed;
             top: 100px;
             right: 20px;
             background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
             color: white;
             padding: 20px;
             border-radius: 15px;
             box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
             display: none;
             z-index: 1002;
             max-width: 400px;
             min-width: 300px;
             animation: slideInBounce 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
             border: 2px solid rgba(255, 255, 255, 0.1);
             backdrop-filter: blur(10px);
             transform-origin: top right;
         }
         
         @keyframes slideInBounce {
             0% { 
                 transform: translateX(100%) scale(0.8); 
                 opacity: 0; 
             }
             60% { 
                 transform: translateX(-10px) scale(1.05); 
                 opacity: 0.8; 
             }
             100% { 
                 transform: translateX(0) scale(1); 
                 opacity: 1; 
             }
         }
         
         @keyframes slideIn {
             from { transform: translateX(100%); opacity: 0; }
             to { transform: translateX(0); opacity: 1; }
         }

        /* 登录注册系统样式 */
        #loginScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 200;
        }
        
        #loginContainer {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            text-align: center;
            min-width: 400px;
            animation: loginSlideUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        @keyframes loginSlideUp {
            0% { 
                transform: translateY(50px) scale(0.9); 
                opacity: 0; 
            }
            100% { 
                transform: translateY(0) scale(1); 
                opacity: 1; 
            }
        }
        
        #loginTitle {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 30px;
            font-weight: bold;
        }
        
        .loginForm {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .loginInput {
            padding: 15px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 10px;
            outline: none;
            transition: border-color 0.3s ease;
        }
        
        .loginInput:focus {
            border-color: #667eea;
        }
        
        .loginButton {
            padding: 15px 30px;
            font-size: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.3s ease;
            margin: 5px;
        }
        
        .loginButton:hover {
            transform: translateY(-2px);
        }
        
        .loginButton.secondary {
            background: #95a5a6;
        }
        
        #registerForm {
            display: none;
        }
        
        /* ID显示弹窗样式 */
        #idDisplayModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 300;
            display: none;
            animation: fadeInOut 4s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        /* 移动端响应式设计 */
        @media screen and (max-width: 768px) {
            /* 登录界面优化 */
            #loginContainer {
                width: 90% !important;
                max-width: 350px !important;
                padding: 20px !important;
                margin: 20px auto !important;
            }
            
            #loginTitle {
                font-size: 24px !important;
                margin-bottom: 20px !important;
            }
            
            .loginInput {
                font-size: 16px !important;
                padding: 12px !important;
                margin-bottom: 15px !important;
            }
            
            .loginButton {
                font-size: 16px !important;
                padding: 12px 20px !important;
                margin: 8px 0 !important;
                width: 100% !important;
            }
            
            /* 游戏按钮优化 */
            .gameButton {
                font-size: 14px !important;
                padding: 10px 15px !important;
                margin: 8px 5px !important;
                min-height: 44px !important;
                min-width: 120px !important;
            }
            
            /* 音乐控制按钮 */
            #musicToggleButton {
                width: 50px !important;
                height: 50px !important;
                font-size: 16px !important;
                top: 10px !important;
                left: 10px !important;
            }
            
            /* 建议和邮箱按钮 */
            #suggestionButton, #mailboxButton, #createRoomButton, #squareButton {
                width: 60px !important;
                height: 60px !important;
                font-size: 14px !important;
                padding: 8px !important;
            }
            
            #suggestionButton {
                top: 10px !important;
                right: 10px !important;
            }
            
            #mailboxButton {
                top: 80px !important;
                right: 10px !important;
            }
            
            #createRoomButton {
                top: 150px !important;
                right: 10px !important;
            }
            
            #squareButton {
                top: 220px !important;
                right: 10px !important;
            }
            
            /* 移动端控制区域 */
            #mobileControlsSingle, #mobileControlsMultiplayer {
                position: fixed !important;
                bottom: 10px !important;
                left: 0 !important;
                right: 0 !important;
                z-index: 1000 !important;
                padding: 10px !important;
                background: rgba(0,0,0,0.1) !important;
                display: none !important;
            }
            
            #mobileControlsSingle {
                flex-direction: column !important;
                align-items: center !important;
                gap: 10px !important;
            }
            
            #mobileControlsMultiplayer {
                flex-direction: row !important;
                justify-content: space-between !important;
                gap: 10px !important;
            }
            
            .player-controls {
                display: flex !important;
                flex-direction: column !important;
                align-items: center !important;
                gap: 8px !important;
                flex: 1 !important;
            }
            
            .player-label {
                color: white !important;
                font-size: 12px !important;
                font-weight: bold !important;
                margin-bottom: 5px !important;
            }
            
            .direction-pad {
                display: grid !important;
                grid-template-columns: repeat(3, 1fr) !important;
                grid-template-rows: repeat(3, 1fr) !important;
                gap: 2px !important;
                width: 120px !important;
                height: 120px !important;
            }
            
            .direction-btn {
                background: rgba(255,255,255,0.8) !important;
                border: none !important;
                border-radius: 8px !important;
                color: #333 !important;
                font-size: 16px !important;
                font-weight: bold !important;
                cursor: pointer !important;
                transition: all 0.1s !important;
                user-select: none !important;
                -webkit-user-select: none !important;
                -webkit-touch-callout: none !important;
                touch-action: manipulation !important;
            }
            
            .direction-btn:active {
                transform: scale(0.95) !important;
            }
            
            .up-btn { grid-column: 2 !important; grid-row: 1 !important; }
            .down-btn { grid-column: 2 !important; grid-row: 3 !important; }
            .left-btn { grid-column: 1 !important; grid-row: 2 !important; }
            .right-btn { grid-column: 3 !important; grid-row: 2 !important; }
            
            .action-buttons {
                display: flex !important;
                gap: 8px !important;
                flex-wrap: wrap !important;
                justify-content: center !important;
            }
            
            .action-btn {
                width: 50px !important;
                height: 50px !important;
                border: none !important;
                border-radius: 50% !important;
                color: white !important;
                font-size: 10px !important;
                font-weight: bold !important;
                cursor: pointer !important;
                transition: all 0.1s !important;
                user-select: none !important;
                -webkit-user-select: none !important;
                -webkit-touch-callout: none !important;
                touch-action: manipulation !important;
            }
            
            .action-btn:active {
                transform: scale(0.9) !important;
            }
            
            .attack-btn { background: #e74c3c !important; }
            .grenade-btn { background: #f39c12 !important; }
            .mine-btn { background: #9b59b6 !important; }
            .rotate-btn { background: #3498db !important; }
            
            .player1-controls .direction-btn {
                background: rgba(52, 152, 219, 0.8) !important;
                color: white !important;
            }
            
            .player2-controls .direction-btn {
                background: rgba(231, 76, 60, 0.8) !important;
                color: white !important;
            }
            
            #skill1Btn, #skill2Btn {
                width: 50px !important;
                height: 50px !important;
                border-radius: 50% !important;
                background: rgba(52, 152, 219, 0.8) !important;
                color: white !important;
                border: none !important;
                font-size: 10px !important;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3) !important;
                touch-action: manipulation !important;
            }
            
            /* 弹窗优化 */
            #suggestionModal, #mailboxModal {
                padding: 10px !important;
            }
            
            #suggestionModalContent, #mailboxModalContent {
                width: 90% !important;
                max-width: 350px !important;
                padding: 20px !important;
                margin: 20px auto !important;
            }
            
            #suggestionTextarea {
                font-size: 16px !important;
                min-height: 120px !important;
            }
            
            /* 通知优化 */
            #suggestionNotification, #developerNotification {
                top: 10px !important;
                right: 10px !important;
                left: 10px !important;
                max-width: none !important;
                width: auto !important;
            }
            
            /* 游戏界面按钮布局 */
            .game-controls {
                flex-direction: column !important;
                gap: 10px !important;
                padding: 10px !important;
            }
            
            /* 防止按钮重叠 */
            body {
                overflow-x: hidden !important;
            }
            
            /* 触摸优化 */
            * {
                -webkit-tap-highlight-color: transparent !important;
                -webkit-touch-callout: none !important;
                -webkit-user-select: none !important;
                user-select: none !important;
            }
            
            input, textarea {
                -webkit-user-select: text !important;
                user-select: text !important;
            }
        }
        
        /* 小屏幕设备进一步优化 */
        @media screen and (max-width: 480px) {
            #loginContainer {
                width: 95% !important;
                padding: 15px !important;
            }
            
            .gameButton {
                font-size: 12px !important;
                padding: 8px 12px !important;
                margin: 5px 3px !important;
                min-width: 100px !important;
            }
            
            #suggestionButton, #mailboxButton, #createRoomButton, #squareButton {
                width: 50px !important;
                height: 50px !important;
                font-size: 12px !important;
            }
            
            #skill1Btn, #skill2Btn {
                width: 50px !important;
                height: 50px !important;
                font-size: 12px !important;
            }
        }

    </style>
</head>
<body>
    <audio id="backgroundMusic" src="background_music.mp3" loop></audio>
    <div id="musicControl" style="position: absolute; top: 10px; left: 10px; z-index: 101;">
        <button id="musicToggleButton" class="play-button" style="background: linear-gradient(45deg, #3498db, #2980b9); color: white; border: none; width: 60px; height: 60px; border-radius: 50%; cursor: pointer; font-size: 20px; position: absolute; top: 20px; left: 20px; z-index: 102; box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3); transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);">▶️</button>
    </div>
    <audio id="gameMusic" src="game_music.mp3" loop></audio>

    <!-- 建议按钮 -->
    <button id="suggestionButton">建议</button>
    
    <!-- 邮箱按钮 -->
    <button id="mailboxButton">
        📧
    </button>
    <span id="unreadCount" class="unread-badge">0</span>
    
    <!-- 广场按钮和创建房间按钮已移动到游戏按钮区域最前面 -->
    
    <!-- 建议弹窗 -->
    <div id="suggestionModal">
        <div id="suggestionModalContent">
            <h2>给开发者的建议</h2>
            <p>请在下方输入您的建议或意见：</p>
            <textarea id="suggestionTextarea" placeholder="请输入您的建议..."></textarea>
            <div class="suggestionButtons">
                <button class="suggestionBtn cancel" id="cancelSuggestionBtn">取消</button>
                <button class="suggestionBtn submit" id="submitSuggestionBtn">提交建议</button>
            </div>
        </div>
    </div>
    
    <!-- 建议通知 -->
    <div id="suggestionNotification"></div>
    
    <!-- 邮箱弹窗 -->
    <div id="mailboxModal">
        <div id="mailboxModalContent">
            <div class="mailbox-header">
                <h2>📧 消息邮箱</h2>
                <button id="closeMailboxBtn" class="close-btn">✕</button>
            </div>
            <div id="mailboxMessages" class="mailbox-messages">
                <div class="empty-state">
                    <p>这里是空空哒</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 开发者通知 -->
    <div id="developerNotification">
    </div>

    <!-- 登录注册界面 -->
    <div id="loginScreen">
        <div id="loginContainer">
            <div id="loginTitle">欢迎到：超级方块！</div>
            
            
            <!-- 登录表单 -->
            <div id="loginForm" class="loginForm">
                <input type="text" id="loginId" class="loginInput" placeholder="请输入您的8位ID" maxlength="8">
                <input type="password" id="loginPassword" class="loginInput" placeholder="请输入6位方方码（密码）" maxlength="6">
                <button id="loginBtn" class="loginButton">登录</button>
                <button id="showRegisterBtn" class="loginButton secondary">注册新账户</button>
                <div style="margin-top: 15px; font-size: 12px; color: #6c757d; text-align: center;">
                    <p style="margin: 5px 0;">💡 提示：按回车键也可以快速登录</p>
                    <p style="margin: 5px 0;">🔒 您的账户信息安全存储在本地</p>
                </div>
            </div>
            
            <!-- 注册表单 -->
            <div id="registerForm" class="loginForm">
                <input type="text" id="registerName" class="loginInput" placeholder="请输入您的名字" maxlength="20">
                <input type="password" id="registerPassword" class="loginInput" placeholder="请输入六位方方码（密码）" maxlength="6">
                <button id="registerBtn" class="loginButton">注册</button>
                <button id="backToLoginBtn" class="loginButton secondary">返回登录</button>
            </div>
        </div>
    </div>
    
    <!-- ID显示弹窗 -->
    <div id="idDisplayModal">
        <h2>注册成功！</h2>
        <p id="idDisplayText">你的ID是：</p>
    </div>

    <div id="welcomeScreen">
        <canvas id="dynamicCanvas"></canvas>
        <div id="welcomeMessage">欢迎玩家1号</div>
        <div id="rulesModal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div style="background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; position: relative;">
                <span style="color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer;" onclick="document.getElementById('rulesModal').style.display = 'none';">&times;</span>
                <h2>游戏规则</h2>
                <p id="rulesContent"></p>
            </div>
        </div>
        <div id="exitConfirmModal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div style="background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 400px; text-align: center;">
                <h2>你真的要离开么？</h2>
                <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                    <button id="confirmExitBtn" class="gameButton" style="background-color: #aaa;">残忍离开</button>
                    <button id="cancelExitBtn" class="gameButton" style="background-color: #3498db;">开心留下</button>
                </div>
            </div>
        </div>
        <div id="difficultyModal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div style="background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 400px; text-align: center;">
                <h2>选择游戏难度</h2>
                <div style="display: flex; flex-direction: column; margin-top: 20px;">
                    <button id="easyModeBtn" class="gameButton difficulty-easy" style="background: linear-gradient(45deg, #2ecc71, #27ae60); color: white; box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);">🌱 简单模式</button>
                    <button id="normalModeBtn" class="gameButton difficulty-normal" style="background: linear-gradient(45deg, #3498db, #2980b9); color: white; box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);">⚡ 正常模式</button>
                    <button id="hardModeBtn" class="gameButton difficulty-hard" style="background: linear-gradient(45deg, #e74c3c, #c0392b); color: white; box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);">🔥 困难模式</button>
                    <button id="hellModeBtn" class="gameButton difficulty-hell" style="background: linear-gradient(45deg, #8e44ad, #9b59b6); color: white; box-shadow: 0 4px 15px rgba(142, 68, 173, 0.4);">💀 地狱模式</button>
                </div>
            </div>
        </div>
        <div id="terrainModal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div style="background-color: #fefefe; margin: 10% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 600px; text-align: center;">
                <h2>选择地形</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px;">
                    <button id="shallowWaterBtn" class="terrainButton" data-terrain="shallow">
                        <div class="terrainIndicator" style="width: 20px; height: 20px; background-color: #888; margin: 0 auto 10px; border-radius: 3px;"></div>
                        浅水
                    </button>
                    <button id="deepWaterBtn" class="terrainButton" data-terrain="deep">
                        <div class="terrainIndicator" style="width: 20px; height: 20px; background-color: #888; margin: 0 auto 10px; border-radius: 3px;"></div>
                        深水
                    </button>
                    <button id="lavaBtn" class="terrainButton" data-terrain="lava">
                        <div class="terrainIndicator" style="width: 20px; height: 20px; background-color: #888; margin: 0 auto 10px; border-radius: 3px;"></div>
                        岩浆
                    </button>
                    <button id="grassBtn" class="terrainButton" data-terrain="grass">
                        <div class="terrainIndicator" style="width: 20px; height: 20px; background-color: #888; margin: 0 auto 10px; border-radius: 3px;"></div>
                        草丛
                    </button>
                </div>
                <div style="margin-top: 20px;">
                    <button id="startGameBtn" class="gameButton" style="background-color: #27ae60;">开始游戏</button>
                </div>
                <div style="margin-top: 15px; font-size: 14px; color: #666; text-align: left;">
                    <h3>地形效果说明：</h3>
                    <p><strong>浅水：</strong>玩家和敌人速度减慢70%</p>
                    <p><strong>深水：</strong>玩家头上出现3个气泡，每5秒消失1个，全部消失后持续扣血且速度减慢60%；敌人进入即减血</p>
                    <p><strong>岩浆：</strong>碰到后无法移动，持续扣血</p>
                    <p><strong>草丛：</strong>玩家进入后隐身，敌人停止射击并显示问号；使用技能或离开草丛时敌人显示感叹号1秒后恢复攻击，20秒内再次进入草丛无效</p>
                </div>
            </div>
        </div>
        <div id="rulesSelectModal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div style="background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 400px; text-align: center;">
                <h2>选择游戏规则模式</h2>
                <div style="display: flex; justify-content: space-around; margin-top: 20px;">
                    <button id="singlePlayerRulesBtn" class="gameButton" style="background-color: blue;">单人模式</button>
                    <button id="multiPlayerRulesBtn" class="gameButton" style="background-color: blue;">双人模式</button>
                </div>
            </div>
        </div>
        
        <!-- 创建房间弹窗系列 -->
        <!-- 房间名输入弹窗 -->
        <div id="roomNameModal" class="modern-modal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div class="modern-modal-content" style="margin: 15% auto; padding: 20px; width: 80%; max-width: 400px; text-align: center; color: white;">
                <h2>🏠 创建房间</h2>
                <p style="margin: 15px 0; opacity: 0.9;">请填写房间名</p>
                <input type="text" id="roomNameInput" placeholder="输入房间名" class="modern-input" style="width: 80%; margin: 10px 0;">
                <div style="margin-top: 20px;">
                    <button onclick="confirmRoomName()" class="modern-button-primary" style="margin: 0 10px;">✅ 确认</button>
                    <button onclick="closeRoomModals()" class="modern-button-danger" style="margin: 0 10px;">❌ 取消</button>
                </div>
            </div>
        </div>
        
        <!-- 游戏模式选择弹窗 -->
        <div id="gameModeModal" class="modern-modal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div class="modern-modal-content" style="margin: 15% auto; padding: 20px; width: 80%; max-width: 400px; text-align: center; color: white;">
                <h2>🎮 选择游戏模式</h2>
                <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 20px;">
                    <button onclick="selectGameMode('yellowVsGreen')" class="modern-button-primary" style="background: linear-gradient(45deg, #FFD700, #32CD32); padding: 15px 20px; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">🟡 黄VS绿 🟢</button>
                    <button onclick="selectGameMode('battleRoyale')" class="modern-button-primary" style="background: linear-gradient(45deg, #FF6B6B, #4ECDC4, #45B7D1, #96CEB4); padding: 15px 20px; font-size: 16px; font-weight: bold; transition: all 0.3s ease;">⚔️ 大乱斗 ⚔️</button>
                </div>
                <div style="margin-top: 20px;">
                    <button onclick="closeRoomModals()" class="modern-button-danger">❌ 取消</button>
                </div>
            </div>
        </div>
        
        <!-- 人数选择弹窗 -->
        <div id="playerCountModal" class="modern-modal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div class="modern-modal-content" style="margin: 15% auto; padding: 20px; width: 80%; max-width: 400px; text-align: center; color: white;">
                <h2>👥 选择人数</h2>
                <div style="display: flex; justify-content: space-around; margin-top: 20px; gap: 10px;">
                    <button onclick="selectPlayerCount(2)" class="modern-button-primary" style="background-color: #2196F3; padding: 15px 20px; font-size: 16px; flex: 1;">👥 二人</button>
                    <button onclick="selectPlayerCount(3)" class="modern-button-primary" style="background-color: #FF9800; padding: 15px 20px; font-size: 16px; flex: 1;">👥👥 三人</button>
                    <button onclick="selectPlayerCount(4)" class="modern-button-primary" style="background-color: #9C27B0; padding: 15px 20px; font-size: 16px; flex: 1;">👥👥👥 四人</button>
                </div>
                <div style="margin-top: 20px;">
                    <button onclick="closeRoomModals()" class="modern-button-danger">❌ 取消</button>
                </div>
            </div>
        </div>
        
        <!-- 公开性选择弹窗 -->
        <div id="privacyModal" class="modern-modal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div class="modern-modal-content" style="margin: 15% auto; padding: 20px; width: 80%; max-width: 400px; text-align: center; color: white;">
                <h2>🔒 选择公开性</h2>
                <div style="display: flex; justify-content: space-around; margin-top: 20px; gap: 15px;">
                    <button onclick="selectPrivacy('public')" class="modern-button-primary" style="background-color: #4CAF50; padding: 15px 20px; font-size: 16px; flex: 1;">🌐 公开</button>
                    <button onclick="selectPrivacy('private')" class="modern-button-primary" style="background-color: #FF5722; padding: 15px 20px; font-size: 16px; flex: 1;">🔐 需密码</button>
                </div>
                <div style="margin-top: 20px;">
                    <button onclick="closeRoomModals()" class="modern-button-danger">❌ 取消</button>
                </div>
            </div>
        </div>
        
        <!-- 密码设置弹窗 -->
        <div id="passwordModal" class="modern-modal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4);">
            <div class="modern-modal-content" style="margin: 15% auto; padding: 20px; width: 80%; max-width: 400px; text-align: center; color: white;">
                <h2>🔐 设置房间密码</h2>
                <p style="margin: 15px 0; opacity: 0.9;">请输入六位房间密码</p>
                <input type="password" id="roomPasswordInput" placeholder="输入6位密码" maxlength="6" class="modern-input" style="width: 80%; margin: 10px 0; text-align: center; letter-spacing: 5px;">
                <div style="margin-top: 20px;">
                    <button onclick="confirmPassword()" class="modern-button-primary" style="margin: 0 10px;">✅ 确认</button>
                    <button onclick="closeRoomModals()" class="modern-button-danger" style="margin: 0 10px;">❌ 取消</button>
                </div>
            </div>
        </div>
        
        <!-- 等候区界面 -->
        <div id="waitingRoomModal" class="modern-modal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.9);">
            <div class="modern-modal-content" style="margin: 10% auto; padding: 30px; width: 80%; max-width: 500px; text-align: center; color: white;">
                <h2>🏠 等候区</h2>
                <div id="roomInfoDisplay" class="room-info-card"></div>
                <div class="room-stats">
                    <div class="stat-item">👥 人数<br><span id="playerCountDisplay" class="stat-value">1/4</span></div>
                    <div class="stat-item">⏰ 倒计时<br><span id="countdownDisplay" class="stat-value">2:00</span></div>
                </div>
                <button id="leaveRoomBtn" onclick="leaveRoom()" class="modern-button-danger">🚪 解散房间</button>
            </div>
        </div>
         
         <!-- 广场界面 -->
         <div id="plazaModal" class="modern-modal" style="display: none; position: fixed; z-index: 20000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.9);" onclick="if(event.target === this) closePlaza()">
             <div class="modern-modal-content" style="margin: 5% auto; padding: 30px; width: 90%; max-width: 600px; color: white; max-height: 80vh; overflow-y: auto;">
                 <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                     <h2>🏛️ 房间广场</h2>
                     <button onclick="closePlaza()" class="modern-button-danger" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding: 5px 10px;">&times;</button>
                 </div>
                 <div id="roomListContainer">
                     <div id="emptyPlaza" style="text-align: center; color: #bdc3c7; font-size: 18px; margin: 50px 0; padding: 30px; background: rgba(255, 255, 255, 0.05); border-radius: 15px; border: 1px dashed rgba(189, 195, 199, 0.3);">🏜️ 这里是空空哒~<br><small style="font-size: 14px; opacity: 0.7;">等待有人创建房间</small></div>
                 </div>
             </div>
         </div>
         
         <!-- 房间详情弹窗 -->
         <div id="roomDetailModal" class="modern-modal" style="display: none; position: fixed; z-index: 20001; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6);" onclick="if(event.target === this) closeRoomDetail()">
             <div class="modern-modal-content" style="margin: 15% auto; padding: 25px; width: 80%; max-width: 400px; color: white; position: relative;">
                 <button onclick="closeRoomDetail()" class="modern-button-danger" style="position: absolute; top: 10px; right: 15px; background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding: 5px 10px;">&times;</button>
                 <div id="roomDetailContent" class="room-info-card"></div>
                 <div style="text-align: center; margin-top: 20px;">
                     <button id="joinRoomBtn" onclick="joinRoom()" class="modern-button-primary" style="margin-right: 10px;">🚪 加入房间</button>
                     <button onclick="closeRoomDetail()" class="modern-button-danger">❌ 取消</button>
                 </div>
             </div>
         </div>
         
         <!-- 密码输入弹窗 -->
         <div id="joinPasswordModal" class="modern-modal" style="display: none; position: fixed; z-index: 20002; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6);" onclick="if(event.target === this) closeJoinPassword()">
             <div class="modern-modal-content" style="margin: 20% auto; padding: 25px; width: 80%; max-width: 350px; color: white; text-align: center;">
                 <h3>🔐 输入房间密码</h3>
                 <input type="password" id="joinPasswordInput" placeholder="输入6位密码" maxlength="6" class="modern-input" style="width: 80%; margin: 15px 0; text-align: center; letter-spacing: 5px;">
                 <div style="margin-top: 20px;">
                     <button onclick="confirmJoinPassword()" class="modern-button-primary" style="margin: 0 10px;">✅ 确认</button>
                     <button onclick="closeJoinPassword()" class="modern-button-danger" style="margin: 0 10px;">❌ 取消</button>
                 </div>
             </div>
         </div>
         
         <button id="squareButton" class="modern-button plaza-button">
            <span class="button-icon">🏛️</span>
            <span class="button-text">广场</span>
          </button>
          <button id="createRoomButton" class="modern-button create-room-button">
            <span class="button-icon">🏠</span>
            <span class="button-text">创建房间</span>
          </button>
        <button id="singlePlayerBtn" class="gameButton play-button">🎮<br>单人对战</button>
        <button id="multiPlayerBtn" class="gameButton play-button">👥<br>双人对战</button>
        <button id="exitBtn" class="gameButton play-button" onclick="showExitConfirm()">🚪<br>退出游戏</button>
        <button id="rulesBtn" class="gameButton play-button" onclick="showRules()">📖<br>游戏规则</button>

    </div>
    <canvas id="gameCanvas"></canvas>
    <!-- 单人模式移动端控制 -->
    <div id="mobileControlsSingle">
        <!-- 虚拟方向键 -->
        <div class="direction-pad">
            <button id="upBtn" class="direction-btn up-btn">↑</button>
            <button id="leftBtn" class="direction-btn left-btn">←</button>
            <button id="rightBtn" class="direction-btn right-btn">→</button>
            <button id="downBtn" class="direction-btn down-btn">↓</button>
        </div>
        
        <!-- 操作按钮 -->
        <div class="action-buttons">
            <button id="attackBtn" class="action-btn attack-btn">攻击</button>
            <button id="grenadeBtn" class="action-btn grenade-btn">手雷</button>
            <button id="skill1Btn" class="action-btn mine-btn">地雷</button>
            <button id="skill2Btn" class="action-btn rotate-btn">旋转</button>
        </div>
    </div>
    
    <!-- 双人模式移动端控制 -->
    <div id="mobileControlsMultiplayer">
        <!-- 玩家1控制区域 -->
        <div class="player-controls player1-controls">
            <div class="player-label">玩家1</div>
            <!-- 玩家1方向键 -->
            <div class="direction-pad">
                <button id="p1UpBtn" class="direction-btn up-btn">↑</button>
                <button id="p1LeftBtn" class="direction-btn left-btn">←</button>
                <button id="p1RightBtn" class="direction-btn right-btn">→</button>
                <button id="p1DownBtn" class="direction-btn down-btn">↓</button>
            </div>
            <!-- 玩家1操作按钮 -->
            <div class="action-buttons">
                <button id="p1AttackBtn" class="action-btn attack-btn">攻击</button>
                <button id="p1GrenadeBtn" class="action-btn grenade-btn">手雷</button>
                <button id="p1MineBtn" class="action-btn mine-btn">地雷</button>
                <button id="p1RotateBtn" class="action-btn rotate-btn">旋转</button>
            </div>
        </div>
        
        <!-- 玩家2控制区域 -->
        <div class="player-controls player2-controls">
            <div class="player-label">玩家2</div>
            <!-- 玩家2方向键 -->
            <div class="direction-pad">
                <button id="p2UpBtn" class="direction-btn up-btn">↑</button>
                <button id="p2LeftBtn" class="direction-btn left-btn">←</button>
                <button id="p2RightBtn" class="direction-btn right-btn">→</button>
                <button id="p2DownBtn" class="direction-btn down-btn">↓</button>
            </div>
            <!-- 玩家2操作按钮 -->
            <div class="action-buttons">
                <button id="p2AttackBtn" class="action-btn attack-btn">攻击</button>
                <button id="p2GrenadeBtn" class="action-btn grenade-btn">手雷</button>
                <button id="p2MineBtn" class="action-btn mine-btn">地雷</button>
                <button id="p2RotateBtn" class="action-btn rotate-btn">旋转</button>
            </div>
        </div>
    </div>
    <script>
        // 炫酷粒子效果系统
        function createParticleSystem() {
            const particlesContainer = document.createElement('div');
            particlesContainer.className = 'particles';
            document.body.appendChild(particlesContainer);
            
            function createParticle() {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                // 随机选择粒子类型
                const types = ['neon', 'plasma', 'energy'];
                const type = types[Math.floor(Math.random() * types.length)];
                particle.classList.add(type);
                
                // 随机大小和位置
                const size = Math.random() * 8 + 2;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                particle.style.left = Math.random() * window.innerWidth + 'px';
                particle.style.bottom = '-10px';
                
                // 随机动画延迟
                particle.style.animationDelay = Math.random() * 2 + 's';
                particle.style.animationDuration = (Math.random() * 4 + 4) + 's';
                
                particlesContainer.appendChild(particle);
                
                // 动画结束后移除粒子
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 8000);
            }
            
            // 定期创建粒子
            setInterval(createParticle, 300);
            
            // 初始创建一些粒子
            for (let i = 0; i < 10; i++) {
                setTimeout(createParticle, i * 100);
            }
        }
        
        // 动态几何图形系统已移除
        
        // 页面加载完成后启动效果
        document.addEventListener('DOMContentLoaded', function() {
            createParticleSystem();
        });
        
        // 房间系统全局变量
        let currentRoom = null;
        let isRoomOwner = false;
        let roomList = [];
        let selectedRoom = null;
        let plazaUpdateInterval = null;
        let roomCountdown = null;
        
        // 房间系统核心函数定义（提前定义以供HTML onclick使用）
        function confirmRoomName() {
             const roomName = document.getElementById('roomNameInput').value.trim();
             if (!roomName) {
                 alert('请输入房间名！');
                 return;
             }
             
             currentRoom = {
                 name: roomName,
                 mode: null,
                 playerCount: null,
                 privacy: null,
                 password: null,
                 currentPlayers: 1,
                 players: [currentUser ? currentUser.name : '玩家1']
             };
             
             document.getElementById('roomNameModal').style.display = 'none';
             document.getElementById('gameModeModal').style.display = 'block';
         }
        
        function closeRoomModals() {
            document.getElementById('roomNameModal').style.display = 'none';
            document.getElementById('gameModeModal').style.display = 'none';
            document.getElementById('playerCountModal').style.display = 'none';
            document.getElementById('privacyModal').style.display = 'none';
            document.getElementById('passwordModal').style.display = 'none';
            
            // 清空输入框
            document.getElementById('roomNameInput').value = '';
            document.getElementById('roomPasswordInput').value = '';
            
            currentRoom = null;
        }
        
        function closePlaza() {
             document.getElementById('plazaModal').style.display = 'none';
             if (plazaUpdateInterval) {
                 clearInterval(plazaUpdateInterval);
                 plazaUpdateInterval = null;
             }
         }
         
         // 选择游戏模式
         function selectGameMode(mode) {
             if (mode === 'yellowVsGreen') {
                 alert('功能开发中');
                 return;
             }
             
             currentRoom.mode = mode;
             document.getElementById('gameModeModal').style.display = 'none';
             document.getElementById('playerCountModal').style.display = 'block';
         }
         
         // 选择人数
         function selectPlayerCount(count) {
             currentRoom.playerCount = count;
             document.getElementById('playerCountModal').style.display = 'none';
             document.getElementById('privacyModal').style.display = 'block';
         }
         
         // 选择公开性
         function selectPrivacy(privacy) {
             currentRoom.privacy = privacy;
             document.getElementById('privacyModal').style.display = 'none';
             
             if (privacy === 'private') {
                 document.getElementById('passwordModal').style.display = 'block';
             } else {
                 createRoomSuccess();
             }
         }
         
         // 确认密码
         function confirmPassword() {
             const password = document.getElementById('roomPasswordInput').value.trim();
             if (password.length !== 6) {
                 alert('请输入6位密码！');
                 return;
             }
             
             currentRoom.password = password;
             document.getElementById('passwordModal').style.display = 'none';
             createRoomSuccess();
         }
         
         // 创建房间成功
         function createRoomSuccess() {
             alert('创建成功！进入等候区');
             isRoomOwner = true;
             showWaitingRoom();
         }
         
         // 显示等候区
         function showWaitingRoom() {
             // 隐藏所有游戏按钮
             const gameButtons = document.querySelectorAll('.gameButton');
             gameButtons.forEach(btn => {
                 if (btn.id !== 'musicToggleBtn') {
                     btn.style.display = 'none';
                 }
             });
             
             // 隐藏创建房间和广场按钮
             document.getElementById('createRoomButton').style.display = 'none';
             document.getElementById('squareButton').style.display = 'none';
             
             // 显示等候区
             document.getElementById('waitingRoomModal').style.display = 'block';
             
             // 更新房间信息显示
             updateRoomInfo();
             
             // 开始倒计时
             startRoomCountdown();
         }
         
         // 更新房间信息显示
         function updateRoomInfo() {
             const roomInfo = document.getElementById('roomInfoDisplay');
             const playerCountDisplay = document.getElementById('playerCountDisplay');
             const leaveBtn = document.getElementById('leaveRoomBtn');
             
             roomInfo.innerHTML = `
                 <div><strong>房间名:</strong> ${currentRoom.name}</div>
                 <div><strong>模式:</strong> ${currentRoom.mode === 'battleRoyale' ? '大乱斗' : currentRoom.mode}</div>
                 <div><strong>公开性:</strong> ${currentRoom.privacy === 'public' ? '公开' : '需密码'}</div>
             `;
             
             playerCountDisplay.textContent = `${currentRoom.currentPlayers}/${currentRoom.playerCount}`;
             
             // 更新按钮文本
             leaveBtn.textContent = isRoomOwner ? '🚪 解散房间' : '🚪 退出房间';
         }
         
         // 开始房间倒计时
         function startRoomCountdown() {
             let timeLeft = 120; // 2分钟
             const countdownDisplay = document.getElementById('countdownDisplay');
             
             roomCountdown = setInterval(() => {
                 const minutes = Math.floor(timeLeft / 60);
                 const seconds = timeLeft % 60;
                 countdownDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                 
                 timeLeft--;
                 
                 // 检查是否人数已满，开始游戏
                 if (currentRoom && currentRoom.currentPlayers >= currentRoom.playerCount) {
                     clearInterval(roomCountdown);
                     startGameCountdown();
                     return;
                 }
                 
                 if (timeLeft < 0) {
                     clearInterval(roomCountdown);
                     alert('时间到！房间自动解散');
                     leaveRoom();
                 }
             }, 1000);
         }
         
         // 离开房间
         function leaveRoom() {
             if (roomCountdown) {
                 clearInterval(roomCountdown);
                 roomCountdown = null;
             }
             
             document.getElementById('waitingRoomModal').style.display = 'none';
             
             // 重新显示游戏按钮
             const gameButtons = document.querySelectorAll('.gameButton');
             gameButtons.forEach(btn => {
                 btn.style.display = 'flex';
             });
             
             // 重新显示创建房间和广场按钮
             document.getElementById('createRoomButton').style.display = 'flex';
             document.getElementById('squareButton').style.display = 'flex';
             
             currentRoom = null;
             isRoomOwner = false;
         }
         
         // 开始游戏倒计时
         function startGameCountdown() {
             let countdown = 3;
             const countdownDisplay = document.getElementById('countdownDisplay');
             countdownDisplay.textContent = countdown;
             
             const countdownInterval = setInterval(() => {
                 countdown--;
                 if (countdown > 0) {
                     countdownDisplay.textContent = countdown;
                 } else {
                     countdownDisplay.textContent = '开始！';
                     setTimeout(() => {
                         startBattleRoyaleGame();
                     }, 1000);
                     clearInterval(countdownInterval);
                 }
             }, 1000);
         }
        
        // 云端用户数据存储系统
        // 云端存储配置 - 使用JSONBin.io服务
        // 注意：如果云端同步失败，系统会自动使用本地存储作为备份
        const CLOUD_STORAGE_URL = 'https://api.jsonbin.io/v3/b/67a0f8e5e41b4d34e4746b8a'; // 云端存储API
        const API_KEY = '$2a$10$8vF9xQzKjL.mH5nP2wR3XeY4tG6hB9sC1dE2fA3gH4iJ5kL6mN7oP8qR9sT0uV1wX2yZ3'; // API密钥
        
        // 云端存储开关 - 可以临时禁用云端同步
        const ENABLE_CLOUD_SYNC = false; // 暂时禁用云端同步，使用本地存储
        
        // 云端存储操作函数
        async function saveUsersToCloud(usersData) {
            // 检查云端同步开关
            if (!ENABLE_CLOUD_SYNC) {
                console.log('📱 云端同步已禁用，使用本地存储模式');
                return true; // 返回成功，避免错误提示
            }
            
            try {
                const response = await fetch(CLOUD_STORAGE_URL, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': API_KEY
                    },
                    body: JSON.stringify({
                        users: usersData,
                        nextUserId: nextUserId,
                        lastUpdated: new Date().toISOString()
                    })
                });
                
                if (response.ok) {
                    console.log('✅ 用户数据已同步到云端');
                    return true;
                } else {
                    console.log('⚠️ 云端同步失败，使用本地存储模式');
                    return false;
                }
            } catch (error) {
                console.log('⚠️ 云端服务不可用，使用本地存储模式');
                return false;
            }
        }
        
        async function loadUsersFromCloud() {
            // 检查云端同步开关
            if (!ENABLE_CLOUD_SYNC) {
                console.log('📱 云端同步已禁用，使用本地存储模式');
                return null;
            }
            
            try {
                const response = await fetch(CLOUD_STORAGE_URL + '/latest', {
                    headers: {
                        'X-Master-Key': API_KEY
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.record && data.record.users) {
                        console.log('✅ 从云端加载用户数据成功');
                        return {
                            users: data.record.users,
                            nextUserId: data.record.nextUserId || 1
                        };
                    }
                }
            } catch (error) {
                // 静默处理网络错误，避免在控制台显示错误信息
                console.log('🌐 云端服务暂时不可用，使用本地数据');
            }
            
            console.log('📱 使用本地数据模式');
            return null;
        }
        
        // 用户数据存储系统（支持云端同步）
        let users = [];
        let currentUser = null;
        let nextUserId = 1;
        
        // 初始化用户数据（优先从云端加载）
        // 数据同步机制
        let syncInterval = null;
        let lastSyncTime = 0;
        const SYNC_INTERVAL = 30000; // 30秒同步一次
        const MIN_SYNC_INTERVAL = 5000; // 最小同步间隔5秒
        
        // 同步用户数据到云端和本地
        async function syncUserData() {
            const now = Date.now();
            if (now - lastSyncTime < MIN_SYNC_INTERVAL) {
                console.log('⏰ 同步间隔太短，跳过此次同步');
                return;
            }
            
            try {
                console.log('🔄 开始同步用户数据...');
                
                // 从云端获取最新数据
                const cloudData = await loadUsersFromCloud();
                
                if (cloudData) {
                    // 合并本地和云端数据
                    const localUsers = JSON.parse(localStorage.getItem('gameUsers')) || [];
                    const mergedUsers = mergeUserData(localUsers, cloudData.users);
                    
                    // 更新本地数据
                    users = mergedUsers;
                    nextUserId = Math.max(cloudData.nextUserId, parseInt(localStorage.getItem('nextUserId')) || 1);
                    
                    // 保存合并后的数据到云端和本地
                    await saveUsersToCloud(mergedUsers);
                    localStorage.setItem('gameUsers', JSON.stringify(mergedUsers));
                    localStorage.setItem('nextUserId', nextUserId.toString());
                    
                    console.log('✅ 数据同步完成，共', mergedUsers.length, '个用户');
                } else {
                    // 如果云端不可用，将本地数据推送到云端
                    await saveUsersToCloud(users);
                    console.log('📤 本地数据已推送到云端');
                }
                
                lastSyncTime = now;
            } catch (error) {
                console.error('❌ 数据同步失败:', error);
            }
        }
        
        // 合并用户数据（避免重复，保留最新信息）
        function mergeUserData(localUsers, cloudUsers) {
            const merged = [...cloudUsers];
            
            localUsers.forEach(localUser => {
                const existingIndex = merged.findIndex(u => u.id === localUser.id);
                if (existingIndex === -1) {
                    // 本地有但云端没有的用户，添加到合并列表
                    merged.push(localUser);
                } else {
                    // 如果本地用户更新时间更晚，使用本地数据
                    const localTime = new Date(localUser.createdAt || 0).getTime();
                    const cloudTime = new Date(merged[existingIndex].createdAt || 0).getTime();
                    if (localTime > cloudTime) {
                        merged[existingIndex] = localUser;
                    }
                }
            });
            
            return merged;
        }
        
        // 启动定期同步
        function startDataSync() {
            if (syncInterval) {
                clearInterval(syncInterval);
            }
            
            syncInterval = setInterval(syncUserData, SYNC_INTERVAL);
            console.log('🔄 定期数据同步已启动，间隔:', SYNC_INTERVAL / 1000, '秒');
        }
        
        // 停止定期同步
        function stopDataSync() {
            if (syncInterval) {
                clearInterval(syncInterval);
                syncInterval = null;
                console.log('⏹️ 定期数据同步已停止');
            }
        }
        
        // 页面可见性变化时同步数据
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                // 页面变为可见时，立即同步一次数据
                console.log('👁️ 页面变为可见，执行数据同步');
                syncUserData();
            }
        });
        
        // 注释掉页面卸载前的同步，避免阻塞页面关闭
        // window.addEventListener('beforeunload', () => {
        //     // 尝试同步数据（可能不会完成，但尽力而为）
        //     syncUserData();
        // });
        
        async function initializeUserData() {
            console.log('🚀 开始初始化用户数据...');
            
            // 尝试从云端加载
            const cloudData = await loadUsersFromCloud();
            
            if (cloudData) {
                console.log('✅ 从云端加载用户数据成功');
                users = cloudData.users;
                nextUserId = cloudData.nextUserId;
            } else {
                console.log('⚠️ 云端加载失败，使用本地数据');
                // 如果云端加载失败，使用本地数据
                users = JSON.parse(localStorage.getItem('gameUsers')) || [];
                nextUserId = parseInt(localStorage.getItem('nextUserId')) || 1;
            }
            
            // 加载永久用户（包括新注册的用户）
            loadPermanentUsers();
            
            // 确保默认管理员用户存在
            const adminUser = {
                name: 'Henry',
                id: '00000000',
                password: '993966'
            };
            
            if (!users.find(u => u.id === '00000000')) {
                users.push(adminUser);
                // 将管理员用户添加到永久用户列表
                addToPermanentUsers(adminUser);
                await saveUsersToCloud(users);
            }
            
            // 同时保存到本地作为备份
            localStorage.setItem('gameUsers', JSON.stringify(users));
            localStorage.setItem('nextUserId', nextUserId.toString());
            
            console.log('📊 用户数据初始化完成，共', users.length, '个用户');
            console.log('👥 当前用户列表:', users.map(u => `${u.name}(${u.id})`).join(', '));
            
            // 启动数据同步
            startDataSync();
        }
        
        // 永久用户管理功能
        function addToPermanentUsers(user) {
            // 获取当前永久用户列表
            let permanentUsersList = JSON.parse(localStorage.getItem('permanentUsers')) || [];
            
            // 检查用户是否已在永久列表中
            if (!permanentUsersList.find(u => u.id === user.id)) {
                permanentUsersList.push(user);
                localStorage.setItem('permanentUsers', JSON.stringify(permanentUsersList));
                console.log('用户已添加到永久保存列表:', user.name, user.id);
            }
        }
        
        function loadPermanentUsers() {
            const permanentUsersList = JSON.parse(localStorage.getItem('permanentUsers')) || [];
            
            // 确保所有永久用户都在当前用户列表中
            permanentUsersList.forEach(permUser => {
                if (!users.find(u => u.id === permUser.id)) {
                    users.push(permUser);
                }
            });
            
            // 更新localStorage中的用户列表
            localStorage.setItem('gameUsers', JSON.stringify(users));
        }
        
        // 注意：用户数据初始化将在页面加载时通过initializeUserData()函数统一处理
        // 这里不再直接调用loadPermanentUsers()，避免初始化顺序混乱
         
         // 登录注册系统功能
        function initLoginSystem() {
            console.log('initLoginSystem函数被调用');
            // 显示登录界面
            const loginScreen = document.getElementById('loginScreen');
            const welcomeScreen = document.getElementById('welcomeScreen');
            
            console.log('loginScreen元素:', loginScreen);
            console.log('welcomeScreen元素:', welcomeScreen);
            
            if (loginScreen) {
                loginScreen.style.display = 'flex';
                loginScreen.style.visibility = 'visible';
                loginScreen.style.zIndex = '200';
            }
            
            if (welcomeScreen) {
                welcomeScreen.style.display = 'none';
                welcomeScreen.style.visibility = 'hidden';
                welcomeScreen.style.zIndex = '-1';
            }
            
            // 确保元素存在后再绑定事件监听器
            const loginBtn = document.getElementById('loginBtn');
            console.log('loginBtn元素:', loginBtn);
            const showRegisterBtn = document.getElementById('showRegisterBtn');
            const registerBtn = document.getElementById('registerBtn');
            const backToLoginBtn = document.getElementById('backToLoginBtn');
            const loginPassword = document.getElementById('loginPassword');
            const registerPassword = document.getElementById('registerPassword');
            
            if (loginBtn) {
                console.log('为loginBtn绑定点击事件');
                loginBtn.removeEventListener('click', handleLogin); // 移除可能存在的旧监听器
                loginBtn.addEventListener('click', function() {
                    console.log('登录按钮被点击了！');
                    handleLogin();
                });
                console.log('loginBtn事件绑定完成');
            } else {
                console.error('loginBtn元素未找到！');
            }
            if (showRegisterBtn) {
                showRegisterBtn.removeEventListener('click', showRegisterForm);
                showRegisterBtn.addEventListener('click', showRegisterForm);
            }
            if (registerBtn) {
                registerBtn.removeEventListener('click', handleRegister);
                registerBtn.addEventListener('click', handleRegister);
            }
            if (backToLoginBtn) {
                backToLoginBtn.removeEventListener('click', showLoginForm);
                backToLoginBtn.addEventListener('click', showLoginForm);
            }
            
            // 回车键登录
            if (loginPassword) {
                loginPassword.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        handleLogin();
                    }
                });
            }
            
            // 回车键注册
            if (registerPassword) {
                registerPassword.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        handleRegister();
                    }
                });
            }
        }
        
        function showRegisterForm() {
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('registerForm').style.display = 'flex';
        }
        
        function showLoginForm() {
            document.getElementById('registerForm').style.display = 'none';
            document.getElementById('loginForm').style.display = 'flex';
        }
        
        async function handleLogin() {
            console.log('handleLogin函数被调用');
            const loginBtn = document.getElementById('loginBtn');
            
            // 禁用按钮并显示加载状态
            if (loginBtn) {
                loginBtn.disabled = true;
                loginBtn.style.backgroundColor = '#cccccc';
                loginBtn.style.cursor = 'not-allowed';
                loginBtn.textContent = '登录中...';
                
                // 设置一个备用的重置机制，防止按钮永远卡住
                setTimeout(() => {
                    console.log('备用重置机制触发');
                    if (loginBtn.textContent === '登录中...') {
                        console.log('检测到按钮仍在加载状态，强制重置');
                        resetLoginButton();
                    }
                }, 10000); // 10秒后强制重置
            }
            
            const id = document.getElementById('loginId').value.trim();
            const password = document.getElementById('loginPassword').value.trim();
            
            console.log('输入的ID:', id, '密码:', password);
            
            try {
                if (!id || !password) {
                    console.log('输入验证失败：ID或密码为空');
                    alert('请输入ID和密码！');
                    resetLoginButton();
                    return;
                }
                
                // 从云端加载最新用户数据
                console.log('正在从云端验证用户凭据...');
                const cloudUsers = await loadUsersFromCloud();
                
                // 如果云端加载失败，使用本地数据作为备份
                const usersToCheck = cloudUsers || users;
                console.log('使用的用户数据源:', cloudUsers ? '云端' : '本地');
                console.log('当前用户数据:', usersToCheck);
                
                console.log('开始查找用户，查找条件：', {id, password});
                const user = usersToCheck.find(u => u.id === id && u.password === password);
                console.log('查找结果：', user);
                
                if (user) {
                    console.log('登录成功，用户:', user);
                    currentUser = user;
                    
                    // 如果使用云端数据成功登录，同步到本地
                    if (cloudUsers) {
                        users = cloudUsers;
                        localStorage.setItem('gameUsers', JSON.stringify(users));
                        console.log('用户数据已同步到本地');
                    }
                    
                    // 重新初始化邮箱（管理员才有邮箱）
                    initializeMailbox();
                    updateUnreadCount();
                    // 登录成功后显示邮箱和建议按钮
                    showMailboxButton();
                    showSuggestionButton();
                    
                    // 显示创建房间和广场按钮
                    const createRoomButton = document.getElementById('createRoomButton');
                    const squareButton = document.getElementById('squareButton');
                    if (createRoomButton) {
                        createRoomButton.style.display = 'flex';
                    }
                    if (squareButton) {
                        squareButton.style.display = 'flex';
                    }
                    console.log('即将调用startGame函数');
                    startGame();
                    console.log('startGame函数调用完成');
                    // 登录成功后不重置按钮，因为界面已经切换
                } else {
                    console.log('登录失败，用户不存在或密码错误');
                    alert('ID或密码错误！');
                    resetLoginButton();
                }
            } catch (error) {
                console.error('登录过程中发生错误:', error);
                alert('登录失败，请稍后重试！');
                resetLoginButton();
            }
        }
        
        function resetLoginButton() {
            const loginBtn = document.getElementById('loginBtn');
            if (loginBtn) {
                loginBtn.disabled = false;
                loginBtn.style.backgroundColor = '';
                loginBtn.style.cursor = 'pointer';
                loginBtn.textContent = '登录';
            }
        }
        
        async function handleRegister() {
            const registerBtn = document.getElementById('registerBtn');
            
            // 禁用按钮并显示加载状态
            if (registerBtn) {
                registerBtn.disabled = true;
                registerBtn.style.backgroundColor = '#cccccc';
                registerBtn.style.cursor = 'not-allowed';
                registerBtn.textContent = '注册中...';
            }
            
            const name = document.getElementById('registerName').value.trim();
            const password = document.getElementById('registerPassword').value.trim();
            
            try {
                if (!name || !password) {
                    console.log('请输入名字和密码！');
                    resetRegisterButton();
                    return;
                }
                
                if (password.length !== 6) {
                    console.log('方方码必须是6位数字！');
                    resetRegisterButton();
                    return;
                }
                
                if (!/^\d{6}$/.test(password)) {
                    console.log('方方码只能包含数字！');
                    resetRegisterButton();
                    return;
                }
                
                // 先从云端加载最新数据，确保ID不重复
                const cloudData = await loadUsersFromCloud();
                if (cloudData) {
                    users = cloudData.users;
                    nextUserId = cloudData.nextUserId;
                }
                
                // 生成8位ID
                const newId = nextUserId.toString().padStart(8, '0');
                
                // 检查ID是否已存在
                if (users.find(u => u.id === newId)) {
                    nextUserId++;
                    resetRegisterButton();
                    handleRegister(); // 递归调用直到找到可用ID
                    return;
                }
                
                // 创建新用户
                const newUser = {
                    name: name,
                    id: newId,
                    password: password,
                    createdAt: new Date().toISOString(),
                    deviceInfo: navigator.userAgent
                };
                
                users.push(newUser);
                
                // 将新用户添加到永久用户列表，确保数据持久化
                addToPermanentUsers(newUser);
                console.log('✅ 新用户已添加到永久用户列表:', newUser.name, newUser.id);
                
                nextUserId++;
                
                // 同步到云端
                const cloudSyncSuccess = await saveUsersToCloud(users);
                
                if (cloudSyncSuccess) {
                    console.log('✅ 新用户已同步到云端:', newUser.name, newUser.id);
                } else {
                    console.log('⚠️ 云端同步失败，但用户已保存到本地');
                }
                
                // 保存到localStorage作为备份
                localStorage.setItem('gameUsers', JSON.stringify(users));
                localStorage.setItem('nextUserId', nextUserId.toString());
                
                // 显示ID弹窗
                showIdDisplay(newId);
                
                // 清空表单
                document.getElementById('registerName').value = '';
                document.getElementById('registerPassword').value = '';
                
                // 重置按钮状态
                resetRegisterButton();
                
                // 3秒后返回登录界面
                setTimeout(() => {
                    showLoginForm();
                }, 3000);
                
            } catch (error) {
                console.error('❌ 注册过程中发生错误:', error);
                resetRegisterButton();
            }
        }
        
        function resetRegisterButton() {
            const registerBtn = document.getElementById('registerBtn');
            if (registerBtn) {
                registerBtn.disabled = false;
                registerBtn.style.backgroundColor = '';
                registerBtn.style.cursor = 'pointer';
                registerBtn.textContent = '注册';
            }
        }
        
        function showIdDisplay(id) {
            document.getElementById('idDisplayText').textContent = `你的ID是：${id}`;
            const modal = document.getElementById('idDisplayModal');
            modal.style.display = 'block';
            
            // 3秒后自动隐藏
            setTimeout(() => {
                modal.style.display = 'none';
            }, 3000);
        }
        
        function startGame() {
            console.log('startGame函数被调用');
            console.log('当前用户:', currentUser);
            
            // 注释掉onGameStart调用，让按钮在登录后保持显示
            // onGameStart();
            
            // 隐藏登录界面
            const loginScreen = document.getElementById('loginScreen');
            if (loginScreen) {
                loginScreen.style.display = 'none';
                loginScreen.style.visibility = 'hidden';
                loginScreen.style.zIndex = '-1';
                console.log('登录界面已隐藏');
            } else {
                console.error('找不到loginScreen元素');
            }
            
            // 显示游戏界面
            const welcomeScreen = document.getElementById('welcomeScreen');
            if (welcomeScreen) {
                welcomeScreen.style.display = 'flex';
                welcomeScreen.style.visibility = 'visible';
                welcomeScreen.style.zIndex = '100';
                welcomeScreen.style.position = 'fixed';
                welcomeScreen.style.top = '0';
                welcomeScreen.style.left = '0';
                welcomeScreen.style.width = '100%';
                welcomeScreen.style.height = '100%';
                welcomeScreen.style.backgroundColor = '#1a1a2e';
                console.log('游戏界面已显示，样式已强制设置');
                console.log('welcomeScreen当前样式:', {
                    display: welcomeScreen.style.display,
                    visibility: welcomeScreen.style.visibility,
                    zIndex: welcomeScreen.style.zIndex
                });
            } else {
                console.error('找不到welcomeScreen元素');
            }
            
            // 更新欢迎信息
            const welcomeMessage = document.getElementById('welcomeMessage');
            if (welcomeMessage && currentUser) {
                welcomeMessage.textContent = `欢迎！${currentUser.name}`;
                console.log('欢迎信息已更新:', welcomeMessage.textContent);
            } else {
                console.error('找不到welcomeMessage元素或currentUser为空');
            }
            
            // 清空登录表单
            const loginId = document.getElementById('loginId');
            const loginPassword = document.getElementById('loginPassword');
            if (loginId) loginId.value = '';
            if (loginPassword) loginPassword.value = '';
            console.log('登录表单已清空');
        }
        
        // 根据电脑特征确定玩家编号的常量
        const playerCount = getPlayerNumberByDevice();

    // 根据设备特征确定玩家编号
    function getPlayerNumberByDevice() {
        // 使用多种设备特征来生成唯一标识
        const deviceInfo = {
            userAgent: navigator.userAgent,
            language: navigator.language,
            platform: navigator.platform,
            screenWidth: screen.width,
            screenHeight: screen.height,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            cookieEnabled: navigator.cookieEnabled,
            onLine: navigator.onLine
        };
        
        // 将设备信息转换为字符串并生成哈希
        const deviceString = JSON.stringify(deviceInfo);
        let hash = 0;
        for (let i = 0; i < deviceString.length; i++) {
            const char = deviceString.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // 转换为32位整数
        }
        
        // 将哈希值转换为1-4之间的玩家编号
        const playerNumber = Math.abs(hash % 4) + 1;
        
        // 存储到localStorage以保持一致性
        const storedPlayerNumber = localStorage.getItem('playerNumber');
        if (storedPlayerNumber) {
            return parseInt(storedPlayerNumber);
        } else {
            localStorage.setItem('playerNumber', playerNumber.toString());
            return playerNumber;
        }
    }

    // 增加玩家计数器（保留原函数名以兼容现有代码，但现在只更新显示）
    function incrementPlayerCount() {
        // playerCount现在是常量，不再改变，只更新显示
        document.getElementById('welcomeMessage').textContent = `欢迎玩家${playerCount}号`;
    }

    // 初始化欢迎消息
    function initWelcomeMessage() {
        document.getElementById('welcomeMessage').textContent = `欢迎玩家${playerCount}号`;
    }
    function showRules() {
        // 直接显示README文件内容，不再询问单人还是双人模式
        const readmeContent = `
            <h1>对战游戏说明</h1>


            <h2>游戏控制</h2>

<h3>玩家1控制</h3>
        <ul>
            <li><strong>WASD键</strong>：移动角色</li>
            <li><strong>鼠标左键</strong>：精确投掷手雷到点击位置(只在单人游戏有效，双人游戏下无效)</li>
            <li><strong>";"键</strong>：范围伤害（只在双人游戏有效，单人游戏下无效）</li>
            <li><strong>“‘”键</strong>：放置地雷</li>
            <li><strong>“空格”键</strong>：旋转射击</li>


<h3>玩家2控制（双人模式）</h3>
        <ul>
            <li><strong>WASD键</strong>：移动角色</li>
            <li><strong>D键</strong>：范围伤害（只在双人游戏有效，单人游戏下无效）</li>
            <li><strong>F键</strong>：放置地雷（敌人踩到它后0.5秒爆炸，伤害范围内敌人）</li>
            <li><strong>G键</strong>：旋转射击（每0.3秒向不同方向发射子弹）</li>
        </ul>

<h2>技能说明</h2>
        <ol>

            <li><strong>手雷攻击</strong>
                <ul><li>冷却时间10秒</li></ul>
            </li>

            <li><strong>地雷技能</strong>
                <ul>
                    <li>放置敌人踩到后0.5秒爆炸</li>
                    <li>冷却时间10秒</li>
                    <li>对范围内敌人造成60点伤害</li>
                </ul>
            </li>

            <li><strong>旋转射击</strong>
                <ul>
                    <li>持续5秒</li>
                    <li>冷却时间60秒</li>
                    <li>每0.1秒发射一次子弹</li>
                    <li>子弹伤害5点</li>
                </ul>
            </li>
        </ol>


<h2>敌人类型</h2>
        <ol>

            <li><strong>紫色敌人</strong>
                <ul>
                    <li>血量高（80点）</li>
                    <li>移动慢</li>
                </ul>
            </li>

            <li><strong>红色敌人</strong>
                <ul>
                    <li>血量低（50点）</li>
                    <li>移动快</li>
                    <li>攻击时移动速度降低20%</li>
                </ul>
            </li>
        </ol>

<h2>游戏特色</h2>
        <ul>
            <li>双人合作模式</li>
            <li>多种敌人类型（紫色和红色敌人）</li>
            <li>强大的Boss战斗系统</li>
            <li>丰富的技能系统（普通攻击、地雷、手雷、旋转射击）</li>
            <li>精确的手雷投掷系统</li>
            <li>动态音效系统</li>
        </ul>

<h2>Boss技能系统</h2>

<h3>Boss攻击机制</h3>
        <ul>
            <li><strong>子弹攻击</strong>：Boss发射的子弹击中玩家时，造成45点伤害并产生爆炸效果，使玩家移动速度减慢70%，减速效果持续10秒</li>
            <li><strong>接触伤害</strong>：当Boss直接接触玩家时，每0.5秒连续扣除0.2血量</li>
            <li><strong>技能释放</strong>：Boss会定期释放多波子弹攻击</li>
        </ul>

<h3>Boss防御机制</h3>
        <ul>
            <li>Boss可以被玩家的子弹击中并扣血</li>
            <li>Boss血量耗尽后会死亡，游戏胜利</li>
        </ul>

<h2>游戏规则</h2>
        <ol>
            <li>击败所有敌人获胜</li>
            <li>玩家血量归零则失败</li>
            <li>游戏结束后可刷新页面返回主界面</li>
        </ol>

        `;
        
        document.getElementById('rulesContent').innerHTML = readmeContent;
        document.getElementById('rulesModal').style.display = 'block';
    }

    const rulesContentSinglePlayer = `
        <h3>单人模式游戏控制</h3>
        <p>方向键：移动角色</p>
        <p>鼠标左键：投出手雷</p>
        <p>单引号键：放置地雷</p>
        <p>空格键：旋转射击</p>

        <h3>技能说明</h3>
        <p>1. <strong>手雷攻击</strong></p>
        <ul>
            <li>冷却时间2秒</li>
            <li>攻击时移动速度降低30%</li>
        </ul>
        <p>2. <strong>地雷技能</strong></p>
        <ul>
            <li>放置敌人踩到后0.5秒爆炸</li>
            <li>冷却时间10秒</li>
            <li>对范围内敌人造成60点伤害</li>
        </ul>
        <p>3. <strong>旋转射击</strong></p>
        <ul>
            <li>持续5秒</li>
            <li>冷却时间60秒</li>
            <li>每0.1秒发射一次子弹</li>
            <li>子弹伤害5点</li>
        </ul>
        <p>4. <strong>范围攻击</strong></p>
        <ul>
            <li>以玩家为中心的瞬间范围攻击</li>
            <li>冷却时间1秒</li>
            <li>对范围内敌人造成15点伤害</li>
        </ul>

        <h3>敌人类型</h3>
        <p>1. <strong>紫色敌人</strong></p>
        <ul>
            <li>血量高（80点）</li>
            <li>移动慢</li>
        </ul>
        <p>2. <strong>红色敌人</strong></p>
        <ul>
            <li>血量低（50点）</li>
            <li>移动快</li>
            <li>攻击时移动速度降低20%</li>
        </ul>

        <h3>游戏规则</h3>
        <p>1. 击败所有敌人获胜</p>
        <p>2. 玩家血量归零则失败</p>
        <p>3. 游戏结束后可刷新页面返回主界面</p>
    `;

    const rulesContentMultiPlayer = `
        <h3>双人模式游戏控制</h3>
        <p>玩家1：WASD或IJKL 移动，D键 随机投掷，鼠标左键 范围攻击，F键 放置地雷，G键 旋转射击</p>
        <p>玩家2：方向键 移动，;键 随机投掷，Shift+鼠标左键 范围攻击，'键 放置地雷，空格键 旋转射击</p>

        <h3>技能说明 (同单人模式)</h3>
        <p>1. <strong>手雷攻击</strong></p>
        <ul>
            <li>冷却时间2秒</li>
            <li>攻击时移动速度降低30%</li>
        </ul>
        <p>2. <strong>地雷技能</strong></p>
        <ul>
            <li>放置敌人踩到后0.5秒爆炸</li>
            <li>冷却时间10秒</li>
            <li>对范围内敌人造成60点伤害</li>
        </ul>
        <p>3. <strong>旋转射击</strong></p>
        <ul>
            <li>持续5秒</li>
            <li>冷却时间60秒</li>
            <li>每0.1秒发射一次子弹</li>
            <li>子弹伤害5点</li>
        </ul>

        <h3>敌人类型 (同单人模式)</h3>
        <p>1. <strong>紫色敌人</strong></p>
        <ul>
            <li>血量高（80点）</li>
            <li>移动慢</li>
        </ul>
        <p>2. <strong>红色敌人</strong></p>
        <ul>
            <li>血量低（50点）</li>
            <li>移动快</li>
            <li>攻击时移动速度降低20%</li>
        </ul>

        <h3>游戏规则</h3>
        <p>1. 击败所有敌人获胜</p>
        <p>2. 玩家血量归零则失败</p>
        <p>3. 游戏结束后可刷新页面返回主界面</p>
    `;

    document.getElementById('singlePlayerRulesBtn').addEventListener('click', function() {
        document.getElementById('rulesSelectModal').style.display = 'none';
        document.getElementById('rulesContent').innerHTML = rulesContentSinglePlayer;
        document.getElementById('rulesModal').style.display = 'block';
    });

    document.getElementById('multiPlayerRulesBtn').addEventListener('click', function() {
        document.getElementById('rulesSelectModal').style.display = 'none';
        document.getElementById('rulesContent').innerHTML = rulesContentMultiPlayer;
        document.getElementById('rulesModal').style.display = 'block';
    });
    // 单人对战按钮点击事件
    document.getElementById('singlePlayerBtn').addEventListener('click', function() {
        // 显示难度选择模态框
        document.getElementById('difficultyModal').style.display = 'block';
    });

    // 全局变量存储选择的难度和地形
    let selectedDifficulty = null;
    let selectedTerrain = [];

    // 难度选择按钮点击事件
    document.getElementById('easyModeBtn').addEventListener('click', function() {
        selectedDifficulty = 'easy';
        showTerrainSelection();
    });
    document.getElementById('normalModeBtn').addEventListener('click', function() {
        selectedDifficulty = 'normal';
        showTerrainSelection();
    });
    document.getElementById('hardModeBtn').addEventListener('click', function() {
        selectedDifficulty = 'hard';
        showTerrainSelection();
    });
    document.getElementById('hellModeBtn').addEventListener('click', function() {
        selectedDifficulty = 'hell';
        showTerrainSelection();
    });

    // 显示地形选择模态框
    function showTerrainSelection() {
        document.getElementById('difficultyModal').style.display = 'none';
        document.getElementById('terrainModal').style.display = 'block';
    }

    // 地形选择按钮点击事件
    document.querySelectorAll('.terrainButton').forEach(button => {
        button.addEventListener('click', function() {
            const terrain = this.getAttribute('data-terrain');
            const indicator = this.querySelector('.terrainIndicator');
            
            if (this.classList.contains('selected')) {
                // 取消选择
                this.classList.remove('selected');
                selectedTerrain = selectedTerrain.filter(t => t !== terrain);
            } else {
                // 选择地形
                this.classList.add('selected');
                if (!selectedTerrain.includes(terrain)) {
                    selectedTerrain.push(terrain);
                }
            }
        });
    });

    // 开始游戏按钮点击事件
    document.getElementById('startGameBtn').addEventListener('click', function() {
        if (selectedDifficulty) {
            const mode = window.gameMode || 'single';
            startActualGame(selectedDifficulty, mode, selectedTerrain);
            window.gameMode = null; // 重置模式标记
            selectedDifficulty = null;
            selectedTerrain = [];
            // 重置地形选择状态
            document.querySelectorAll('.terrainButton').forEach(btn => {
                btn.classList.remove('selected');
            });
        }
    });

    // 开始游戏函数
    function startActualGame(difficulty, mode = 'single', terrains = []) { // mode: 'single' or 'multi', terrains: array of selected terrains
        // 游戏真正开始时隐藏按钮
        onGameStart();
        
        document.getElementById('difficultyModal').style.display = 'none';
        document.getElementById('terrainModal').style.display = 'none';
        hideSuggestionButton(); // 隐藏建议按钮
        incrementPlayerCount();
        initWelcomeMessage();
        document.getElementById('welcomeScreen').style.display = 'none';
        const gameCanvas = document.getElementById('gameCanvas');
        gameCanvas.style.filter = 'none';
        gameCanvas.classList.add('game-active');
        
        // 设置游戏背景为黑色
        document.body.style.backgroundColor = 'black';
        document.body.style.backgroundImage = 'none';
        
        currentGameMode = mode; // 设置当前游戏模式
        currentTerrains = terrains; // 设置当前地形
        init(difficulty, mode, terrains); // 初始化游戏并传入难度参数、模式和地形
        gameRunning = true; // 游戏状态设置为运行中
        gameStartTime = Date.now(); // 记录游戏开始时间
    lastBossSpawnCheckTime = 0; // 初始化上次检查Boss生成的时间为0，确保第一次检查在30秒后
        gameLoop(); // 开始游戏循环

        // 停止大厅音乐，播放游戏音乐
        // 停止大厅音乐，播放游戏音乐
        const bgMusic = document.getElementById('backgroundMusic');
        if (bgMusic && !bgMusic.paused) {
            bgMusic.pause();
        }
        const gameMusic = document.getElementById('gameMusic');
        if (gameMusic) {
            gameMusic.play();
        }
    }


    // 双人对战按钮点击事件
    document.getElementById('multiPlayerBtn').addEventListener('click', function() {
        // 显示难度选择模态框
        document.getElementById('difficultyModal').style.display = 'block';
        // 设置为双人模式标记
        window.gameMode = 'multi';
    });


    // 显示退出确认模态框
    function showExitConfirm() {
        document.getElementById('exitConfirmModal').style.display = 'block';
    }

    // “残忍离开”按钮点击事件
    document.getElementById('confirmExitBtn').addEventListener('click', function() {
        window.close();
    });

    // “开心留下”按钮点击事件
    document.getElementById('cancelExitBtn').addEventListener('click', function() {
        document.getElementById('exitConfirmModal').style.display = 'none';
    });
    let lastPurpleEnemySpawnTime = Date.now();
let lastRedEnemySpawnTime = Date.now();

// 音乐控制逻辑
const musicToggleButton = document.getElementById('musicToggleButton');
const backgroundMusic = document.getElementById('backgroundMusic');
let isMusicPlaying = false;

musicToggleButton.addEventListener('click', () => {
    if (isMusicPlaying) {
        backgroundMusic.pause();
        musicToggleButton.textContent = '▶️';
    } else {
        backgroundMusic.play().catch(e => console.log("背景音乐播放失败: ", e));
        musicToggleButton.textContent = '⏸️';
    }
    isMusicPlaying = !isMusicPlaying;
});

// 初始状态，如果音乐是自动播放的，则更新按钮状态
backgroundMusic.addEventListener('play', () => {
    musicToggleButton.textContent = '⏸️';
    isMusicPlaying = true;
});

backgroundMusic.addEventListener('pause', () => {
    musicToggleButton.textContent = '▶️';
    isMusicPlaying = false;
});

// 尝试在页面加载时播放音乐，如果失败则等待用户交互
backgroundMusic.play().then(() => {
    musicToggleButton.textContent = '⏸️';
    isMusicPlaying = true;
}).catch(e => {
    console.log("背景音乐自动播放失败，等待用户交互: ", e);
    musicToggleButton.textContent = '▶️';
    isMusicPlaying = false;
});

// 玩家对象
// Player object should be defined here, before any functions

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const PLAYER_SPEED = 5;
const PLAYER_ATTACK_SPEED_REDUCTION = 0.3; // 攻击时速度降低30%
const ATTACK_RANGE = 100; // 普通攻击范围
const ATTACK_DAMAGE = 20; // 增加攻击力
const ATTACK_DURATION = 5000; // 攻击持续5秒
const ATTACK_COOLDOWN = 2000; // 攻击冷却2秒
const PLAYER_MAX_HEALTH = 100;
const PLAYER_ATTACK_COOLDOWN = 200; // 默认攻击冷却时间 (毫秒)
const GRENADE_COOLDOWN = 2000; // 默认手雷冷却时间 (毫秒)
const MINE_COOLDOWN = 2000; // 默认地雷冷却时间 (毫秒)
const ROTATE_SHOOT_COOLDOWN = 40000; // 默认旋转射击冷却时间 (毫秒)

// 游戏状态
// gameRunning变量已在其他地方声明
let lastEnemyAttackTime = null;
let gameStartTime = 0; // 游戏开始时间
let lastBossSpawnCheckTime = 0; // 上次检查Boss生成的时间
let currentGameMode = 'single'; // 当前游戏模式：'single' 或 'multi'
let player = {};
let player2 = null; // Player 2 object, initially null
let boss = null; // Boss 对象，初始为 null

player = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        width: 30, // 固定角色大小
        height: 30,
        color: '#87CEEB',
        health: PLAYER_MAX_HEALTH,
        speed: PLAYER_SPEED,
        isAttacking: false,
        attackStartTime: 0,
        attackEndTime: 0,
        canMove: true,
        canAttack: true,
        moveUp: false,
        moveDown: false,
        moveLeft: false,
        moveRight: false,
        cnt: 0,
        rotationAngle: 0, // 初始化旋转角度
        // 地雷技能相关属性
        canPlaceMine: true,
        canMove: true,
        lastMinePlaced: 0,
    // 旋转射击技能相关属性
    isRotateShooting: false,
    rotateShootStartTime: 0,
    rotateShootEndTime: 0,
    lastBulletTime: 0,
    rotationAngle: 0,
    // 手雷技能相关属性
    canThrowGrenade: true,
    lastGrenadeThrowTime: 0,
    canAreaAttack: true, // 是否可以进行范围攻击
    lastAreaAttackTime: 0, // 上次范围攻击时间
    // 旋转射击技能相关属性
    canUseRotateShoot: true,
    rotateShootCharges: 0,
    lastRotateShootChargeTime: 0,
    isChargingRotateShoot: false,
    rotateShootActive: false,
    rotateShootStartTime: 0,
    rotateShootX: 0,
    rotateShootY: 0
};

//判断客户是不是电脑端
const isPC = /Windows|Macintosh|Linux/.test(navigator.userAgent);

// 初始化移动端控制
function initMobileControls() {
    if (!isPC) {
        // 根据游戏模式显示相应的控制界面
        if (player2) {
            // 双人模式
            document.getElementById('mobileControlsSingle').style.display = 'none';
            document.getElementById('mobileControlsMultiplayer').style.display = 'flex';
            initMultiplayerTouchControls();
        } else {
            // 单人模式
            document.getElementById('mobileControlsSingle').style.display = 'flex';
            document.getElementById('mobileControlsMultiplayer').style.display = 'none';
            initSinglePlayerTouchControls();
        }
    }
}

// 单人模式触屏控制
function initSinglePlayerTouchControls() {
    // 虚拟方向键事件监听
    // 上方向键
    document.getElementById('upBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        player.moveUp = true;
        this.style.background = 'rgba(255,255,255,1)';
    });
    document.getElementById('upBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        player.moveUp = false;
        this.style.background = 'rgba(255,255,255,0.8)';
    });
    
    // 下方向键
    document.getElementById('downBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        player.moveDown = true;
        this.style.background = 'rgba(255,255,255,1)';
    });
    document.getElementById('downBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        player.moveDown = false;
        this.style.background = 'rgba(255,255,255,0.8)';
    });
    
    // 左方向键
    document.getElementById('leftBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        player.moveLeft = true;
        this.style.background = 'rgba(255,255,255,1)';
    });
    document.getElementById('leftBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        player.moveLeft = false;
        this.style.background = 'rgba(255,255,255,0.8)';
    });
    
    // 右方向键
    document.getElementById('rightBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        player.moveRight = true;
        this.style.background = 'rgba(255,255,255,1)';
    });
    document.getElementById('rightBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        player.moveRight = false;
        this.style.background = 'rgba(255,255,255,0.8)';
    });
    
    // 攻击按钮
    document.getElementById('attackBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (player.canAttack) {
            player.isAttacking = true;
            player.attackTimer = 10;
            player.canAttack = false;
            setTimeout(() => {
                player.canAttack = true;
            }, player.attackCooldown);
        }
        this.style.background = '#c0392b';
    });
    document.getElementById('attackBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        this.style.background = '#e74c3c';
    });
    
    // 手雷按钮
    document.getElementById('grenadeBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        handlePlayerGrenade(player);
        this.style.background = '#d68910';
    });
    document.getElementById('grenadeBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        this.style.background = '#f39c12';
    });
    
    // 地雷按钮
    document.getElementById('skill1Btn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        handlePlayerMine(player);
        this.style.background = '#8e44ad';
    });
    document.getElementById('skill1Btn').addEventListener('touchend', function(e) {
        e.preventDefault();
        this.style.background = '#9b59b6';
    });
    
    // 旋转射击按钮
    document.getElementById('skill2Btn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        activateRotateShoot(player);
        this.style.background = '#2980b9';
    });
    document.getElementById('skill2Btn').addEventListener('touchend', function(e) {
        e.preventDefault();
        this.style.background = '#3498db';
    });
    
    // 防止触摸时页面滚动
    document.getElementById('mobileControlsSingle').addEventListener('touchmove', function(e) {
        e.preventDefault();
    });
}

// 双人模式触屏控制
function initMultiplayerTouchControls() {
    // 玩家1控制
    // 方向键
    document.getElementById('p1UpBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        player.moveUp = true;
        this.style.background = 'rgba(52, 152, 219, 1)';
    });
    document.getElementById('p1UpBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        player.moveUp = false;
        this.style.background = 'rgba(52, 152, 219, 0.8)';
    });
    
    document.getElementById('p1DownBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        player.moveDown = true;
        this.style.background = 'rgba(52, 152, 219, 1)';
    });
    document.getElementById('p1DownBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        player.moveDown = false;
        this.style.background = 'rgba(52, 152, 219, 0.8)';
    });
    
    document.getElementById('p1LeftBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        player.moveLeft = true;
        this.style.background = 'rgba(52, 152, 219, 1)';
    });
    document.getElementById('p1LeftBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        player.moveLeft = false;
        this.style.background = 'rgba(52, 152, 219, 0.8)';
    });
    
    document.getElementById('p1RightBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        player.moveRight = true;
        this.style.background = 'rgba(52, 152, 219, 1)';
    });
    document.getElementById('p1RightBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        player.moveRight = false;
        this.style.background = 'rgba(52, 152, 219, 0.8)';
    });
    
    // 玩家1操作按钮
    document.getElementById('p1AttackBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (player.canAttack) {
            player.isAttacking = true;
            player.attackTimer = 10;
            player.canAttack = false;
            setTimeout(() => {
                player.canAttack = true;
            }, player.attackCooldown);
        }
    });
    
    document.getElementById('p1GrenadeBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        handlePlayerGrenade(player);
    });
    
    document.getElementById('p1MineBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        handlePlayerMine(player);
    });
    
    document.getElementById('p1RotateBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        activateRotateShoot(player);
    });
    
    // 玩家2控制
    // 方向键
    document.getElementById('p2UpBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (player2) {
            player2.moveUp = true;
        }
        this.style.background = 'rgba(231, 76, 60, 1)';
    });
    document.getElementById('p2UpBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        if (player2) {
            player2.moveUp = false;
        }
        this.style.background = 'rgba(231, 76, 60, 0.8)';
    });
    
    document.getElementById('p2DownBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (player2) {
            player2.moveDown = true;
        }
        this.style.background = 'rgba(231, 76, 60, 1)';
    });
    document.getElementById('p2DownBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        if (player2) {
            player2.moveDown = false;
        }
        this.style.background = 'rgba(231, 76, 60, 0.8)';
    });
    
    document.getElementById('p2LeftBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (player2) {
            player2.moveLeft = true;
        }
        this.style.background = 'rgba(231, 76, 60, 1)';
    });
    document.getElementById('p2LeftBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        if (player2) {
            player2.moveLeft = false;
        }
        this.style.background = 'rgba(231, 76, 60, 0.8)';
    });
    
    document.getElementById('p2RightBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (player2) {
            player2.moveRight = true;
        }
        this.style.background = 'rgba(231, 76, 60, 1)';
    });
    document.getElementById('p2RightBtn').addEventListener('touchend', function(e) {
        e.preventDefault();
        if (player2) {
            player2.moveRight = false;
        }
        this.style.background = 'rgba(231, 76, 60, 0.8)';
    });
    
    // 玩家2操作按钮
    document.getElementById('p2AttackBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (player2 && player2.canAttack) {
            player2.isAttacking = true;
            player2.attackTimer = 10;
            player2.canAttack = false;
            setTimeout(() => {
                player2.canAttack = true;
            }, player2.attackCooldown);
        }
    });
    
    document.getElementById('p2GrenadeBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (player2) {
            handlePlayerGrenade(player2);
        }
    });
    
    document.getElementById('p2MineBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (player2) {
            handlePlayerMine(player2);
        }
    });
    
    document.getElementById('p2RotateBtn').addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (player2) {
            activateRotateShoot(player2);
        }
    });
    
    // 防止触摸时页面滚动
    document.getElementById('mobileControlsMultiplayer').addEventListener('touchmove', function(e) {
        e.preventDefault();
    });
}

// 在游戏开始时调用移动端控制初始化
if (!isPC) {
    initMobileControls();
}

// 敌人数组
let enemies = [];

// 地雷数组
let mines = [];

// 子弹数组
let bullets = [];

// 紫色敌人子弹数组
let purpleEnemyBullets = [];

// 红色敌人子弹数组
let redEnemyBullets = [];

// 手雷数组
let grenades = [];

// 爆炸效果数组
let explosions = [];

// 决赛圈相关变量
let finalCircleActive = false; // 决赛圈是否激活
let finalCircleRadius = 0; // 当前决赛圈半径
let finalCircleCenterX = 0; // 决赛圈中心X坐标
let finalCircleCenterY = 0; // 决赛圈中心Y坐标
let finalCircleStartTime = 0; // 决赛圈开始时间
let gameWinner = null; // 游戏获胜者
let finalBattleStarted = false; // 是否已开始决战
let lastCircleDamageTime = 0; // 上次决赛圈伤害时间

// 地形相关变量
let currentTerrains = []; // 当前选择的地形
let terrainAreas = []; // 地形区域数组
let playerBubbles = { player1: 3, player2: 3 }; // 玩家气泡数量
let lastBubbleLossTime = { player1: 0, player2: 0 }; // 上次失去气泡时间
let playerInGrass = { player1: false, player2: false }; // 玩家是否在草丛中
let grassCooldown = { player1: 0, player2: 0 }; // 草丛冷却时间
let enemyQuestionMarks = []; // 敌人问号状态

// 生成敌人
canvas.width = window.innerWidth * 0.8;
canvas.height = window.innerHeight * 0.8;

// 移除自动开始游戏

function generateEnemy(type, targetPlayer = player) { // targetPlayer 默认为 player1
    let health, speed, color;
    switch (type) {
        case 'purple':
            health = PURPLE_ENEMY_HEALTH;
            speed = PURPLE_ENEMY_SPEED;
            color = '#9b59b6'; // 紫色
            break;
        case 'red':
            health = RED_ENEMY_HEALTH;
            speed = RED_ENEMY_SPEED;
            color = '#e74c3c'; // 红色
            break;
        default:
            health = ENEMY_MAX_HEALTH;
            speed = ENEMY_SPEED;
            color = '#e74c3c'; // 默认红色
    }

    let x, y;
    let attempts = 0;
    const maxAttempts = 100;

    do {
        x = Math.random() * (canvas.width - 30);
        y = Math.random() * (canvas.height - 30);
        attempts++;

        // 如果尝试次数过多，则放宽条件
        if (attempts >= maxAttempts) break;

    } while (Math.sqrt(Math.pow(x - player.x, 2) + Math.pow(y - player.y, 2)) < ATTACK_RANGE);

    const enemy = {
        x: x,
        y: y,
        width: canvas.width / 20,
        height: canvas.height / 20,
        color: color,
        health: health,
        maxHealth: health,
        speed: speed,
        isDead: false,
        isStunned: false,
        stunStartTime: 0,
        tickDamageStartTime: 0,
        targetPlayer: targetPlayer, // 添加目标玩家属性
        type: type, // 添加敌人类型
        lastShootTime: 0, // 添加上次射击时间（紫色敌人需要）
        canShoot: true // 初始化射击能力
    };
    enemies.push(enemy);
}



const ENEMY_MAX_HEALTH = 50;
const PURPLE_ENEMY_HEALTH = 80; // 紫色敌人血量
const PURPLE_ENEMY_SPEED = 0.05; // 紫色敌人速度
const PURPLE_ENEMY_BULLET_SPEED = 3; // 紫色敌人子弹速度
const PURPLE_ENEMY_BULLET_DAMAGE = 5; // 紫色敌人子弹伤害
const PURPLE_ENEMY_SHOOT_INTERVAL = 3000; // 紫色敌人射击间隔（3秒）
const RED_ENEMY_SHOOT_INTERVAL = 2000; // 红色敌人射击间隔（2秒）
const RED_ENEMY_HEALTH = 40; // 红色敌人血量
const RED_ENEMY_SPEED = 0.2; // 红色敌人速度
 const ENEMY_SPEED_RECOVERY_DURATION = 2000; // 敌人速度恢复时间（毫秒）
const ENEMY_SPEED = 0.2; // 默认敌人速度

// Boss 常量
const BOSS_MAX_HEALTH = 600;
const BOSS_SPEED = 0.1; // Boss 移动速度
const BOSS_SKILL_COOLDOWN = 5000; // Boss 技能冷却时间（毫秒）
const BOSS_BULLET_SPEED = 5; // Boss 子弹速度
const BOSS_BULLET_COUNT = 8; // Boss 每次技能发射的子弹方向数
const BOSS_BULLET_WAVES = 1; // Boss 技能连续发射的子弹波次（每轮只发射一波）
const BOSS_SPAWN_TIME = 30000; // Boss 首次出现时间（毫秒）
const BOSS_SPAWN_CHANCE = 0.3; // Boss 每次出现概率

// 爆炸效果常量
const EXPLOSION_DURATION = 30; // 爆炸动画持续帧数（增加持续时间）
const EXPLOSION_MAX_RADIUS = 35; // 爆炸最大半径（增大爆炸范围）
const EXPLOSION_PARTICLES = 8; // 爆炸粒子数量

// 敌人生成常量
const PURPLE_ENEMY_SPAWN_INTERVAL = 30000; // 30秒
const PURPLE_ENEMY_SPAWN_CHANCE = 0.5; // 50%概率
const RED_ENEMY_SPAWN_INTERVAL = 10000; // 10秒
const RED_ENEMY_SPAWN_CHANCE = 0.7; // 70%概率

// 地雷技能常量
const MINE_EXPLOSION_RANGE = 100;
const MINE_DAMAGE = 60; // 增强地雷伤害
// 地雷技能冷却时间常量已在前面定义,这里删除重复声明
const MINE_COUNTDOWN = 3000; // 3秒倒计时

// 旋转射击技能常量 // 10秒持续时间
// 旋转射击冷却时间已在前面定义,这里删除重复声明
const ROTATE_SHOOT_INTERVAL = 40; // 0.2秒发射一次
const ROTATE_SHOOT_DAMAGE = 25; // 子弹伤害
const ROTATE_SHOOT_SPEED = 10; // 子弹速度
const ROTATE_SHOOT_DURATION = 5000; // 10秒持续时间
const ROTATE_SHOOT_RADIUS = 5; // 子弹半径，使其变小

// 敌人状态常量
const ENEMY_STUN_DURATION = 400; // 敌人停止移动0.1秒
const ENEMY_TICK_DAMAGE_INTERVAL = 50; // 每0.05秒扣血
const ENEMY_TICK_DAMAGE_AMOUNT = 3; // 每次扣血3点

// 手雷技能常量
const GRENADE_DAMAGE = 70; // 手雷伤害
const GRENADE_EXPLOSION_RADIUS = 70; // 手雷爆炸范围

// 引力炸弹技能常量
const GRAVITY_BOMB_COOLDOWN = 15000; // 引力炸弹冷却时间 (15秒)
const GRAVITY_BOMB_DURATION = 3000; // 引力炸弹持续时间 (3秒)
const GRAVITY_BOMB_ATTRACT_RADIUS = 125; // 吸引范围
const GRAVITY_BOMB_EXPLOSION_RADIUS = 150; // 爆炸范围
const GRAVITY_BOMB_DAMAGE = 100; // 爆炸伤害
const GRAVITY_BOMB_SLOW_PERCENTAGE = 0.9; // 减速90%
const GRAVITY_BOMB_BLEED_PERCENTAGE = 0.7; // 持续扣血70%
const GRAVITY_BOMB_MAX_CHARGES = 10; // 最大充能次数
const GRAVITY_BOMB_CHARGE_INTERVAL = 100; // 每次点击空格的间隔，用于充能

// 技能禁用状态
const SKILL_DISABLED_STATUS = '禁用中';
// 瞬间范围攻击常量 (Player 1)
const AREA_ATTACK_RADIUS = 100; // 范围攻击半径
const AREA_ATTACK_DAMAGE = 15; // 范围攻击伤害
const AREA_ATTACK_COOLDOWN = 1000; // 范围攻击冷却时间（毫秒）

// 手雷冷却时间已在前面定义,这里删除重复声明
const GRENADE_MIN_FLIGHT_TIME = 400; // 手雷最小飞行时间0.1秒
const GRENADE_MAX_FLIGHT_TIME = 700; // 手雷最大飞行时间1秒

// 决赛圈相关常量
const FINAL_CIRCLE_SHRINK_SPEED = 0.5; // 决赛圈缩小速度（每帧缩小0.5像素）
const FINAL_CIRCLE_DAMAGE = 5; // 决赛圈伤害
const FINAL_CIRCLE_DAMAGE_INTERVAL = 1000; // 决赛圈伤害间隔（毫秒）
const PVP_DAMAGE = 10; // 玩家互相攻击伤害
const FINAL_CIRCLE_MIN_RADIUS = 80; // 决赛圈最小半径（稍微小一点增加紧张感）

// 地形相关常量
const SHALLOW_WATER_SPEED_REDUCTION = 0.3; // 浅水速度减少70%
const DEEP_WATER_SPEED_REDUCTION = 0.4; // 深水速度减少60%
const DEEP_WATER_BUBBLE_INTERVAL = 5000; // 深水气泡消失间隔（5秒）
const DEEP_WATER_DAMAGE = 2; // 深水伤害
const LAVA_DAMAGE = 5; // 岩浆伤害
const GRASS_COOLDOWN_TIME = 20000; // 草丛冷却时间（20秒）
const TERRAIN_AREA_SIZE = 150; // 地形区域大小
// 获取画布和上下文



function init(difficulty, mode, terrains = []) {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    // const ROTATE_SHOOT_RADIUS = canvas.width / 100; // 子弹半径
    // 根据难度调整游戏参数
    let currentPurpleEnemyHealth = PURPLE_ENEMY_HEALTH;
    let currentRedEnemyHealth = RED_ENEMY_HEALTH;
    let currentPurpleEnemySpeed = PURPLE_ENEMY_SPEED;
    let currentRedEnemySpeed = RED_ENEMY_SPEED;
    let currentPurpleEnemySpawnInterval = PURPLE_ENEMY_SPAWN_INTERVAL;
    let currentRedEnemySpawnInterval = RED_ENEMY_SPAWN_INTERVAL;
    let currentPlayerMaxHealth = PLAYER_MAX_HEALTH;
    let currentPlayerAttackCooldown = PLAYER_ATTACK_COOLDOWN;
    let currentGrenadeCooldown = GRENADE_COOLDOWN;
    let currentMineCooldown = MINE_COOLDOWN;
    let currentRotateShootCooldown = ROTATE_SHOOT_COOLDOWN;
    let initialRedEnemies = 5; // 默认初始红色敌人数量
    let initialPurpleEnemies = 5; // 默认初始紫色敌人数量

    if (mode === 'multi') {
        initialRedEnemies = 10; // 双人模式下10个红色敌人
        initialPurpleEnemies = 5; // 双人模式下5个紫色敌人
        player2 = {
            x: canvas.width / 2 + 100, // 玩家2初始位置
            y: canvas.height / 2,
            width: 30,
            height: 30,
            color: '#FFD700', // 玩家2颜色
            health: currentPlayerMaxHealth,
            speed: PLAYER_SPEED,
            isAttacking: false,
            attackStartTime: 0,
            attackEndTime: 0,
            canMove: true,
            canAttack: true,
            moveUp: false,
            moveDown: false,
            moveLeft: false,
            moveRight: false,
            cnt: 0,
            rotationAngle: 0,
            canPlaceMine: true,
            lastMinePlaced: 0,
            isRotateShooting: false,
            rotateShootStartTime: 0,
            rotateShootEndTime: 0,
            lastBulletTime: 0,
            canThrowGrenade: true,
            lastGrenadeThrowTime: 0,
            canUseRotateShoot: true,
            rotateShootCharges: 0,
            lastRotateShootChargeTime: 0,
            isChargingRotateShoot: false,
            attackCooldown: currentPlayerAttackCooldown, // 添加攻击冷却时间
            canAreaAttack: true, // 添加范围攻击能力
            lastAreaAttackTime: 0, // 添加上次范围攻击时间
            trail: [] // 玩家2移动轨迹
        };
    }

    switch (difficulty) {
        case 'easy':
            currentPurpleEnemyHealth = 60;
            currentRedEnemyHealth = 30;
            currentPurpleEnemySpeed = 0.03;
            currentRedEnemySpeed = 0.2;
            currentPurpleEnemySpawnInterval = 40000;
            currentRedEnemySpawnInterval = 15000;
            currentPlayerMaxHealth = 120;
            currentPlayerAttackCooldown = 300; // 简单难度攻击冷却时间
            currentGrenadeCooldown = 3000; // 简单难度手雷冷却时间
            currentMineCooldown = 3000; // 简单难度地雷冷却时间
            currentRotateShootCooldown = 5000; // 简单难度旋转射击冷却时间
            initialRedEnemies = 3; // 简单难度初始红色敌人数量
            initialPurpleEnemies = 2; // 简单难度初始紫色敌人数量
            break;
        case 'normal':
            // 默认值，无需修改
            break;
        case 'hard':
            currentPurpleEnemyHealth = 100;
            currentRedEnemyHealth = 60;
            currentPurpleEnemySpeed = 0.07;
            currentRedEnemySpeed = 0.6;
            currentPurpleEnemySpawnInterval = 20000;
            currentRedEnemySpawnInterval = 8000;
            currentPlayerMaxHealth = 80;
            currentPlayerAttackCooldown = 100; // 困难难度攻击冷却时间
            currentGrenadeCooldown = 1000; // 困难难度手雷冷却时间
            currentMineCooldown = 1000; // 困难难度地雷冷却时间
            currentRotateShootCooldown = 2000; // 困难难度旋转射击冷却时间
            initialRedEnemies = 7; // 困难难度初始红色敌人数量
            initialPurpleEnemies = 3; // 困难难度初始紫色敌人数量
            break;
        case 'hell':
            currentPurpleEnemyHealth = 120;
            currentRedEnemyHealth = 80;
            currentPurpleEnemySpeed = 0.09;
            currentRedEnemySpeed = 0.8;
            currentPurpleEnemySpawnInterval = 15000;
            currentRedEnemySpawnInterval = 5000;
            currentPlayerMaxHealth = 60;
            currentPlayerAttackCooldown = 50; // 地狱难度攻击冷却时间
            currentGrenadeCooldown = 500; // 地狱难度手雷冷却时间
            currentMineCooldown = 500; // 地狱难度地雷冷却时间
            currentRotateShootCooldown = 1000; // 地狱难度旋转射击冷却时间
            initialRedEnemies = 10; // 地狱难度初始红色敌人数量
            initialPurpleEnemies = 5; // 地狱难度初始紫色敌人数量
            break;
    }

    // 更新玩家初始血量
    player.health = currentPlayerMaxHealth;
    player.maxHealth = currentPlayerMaxHealth;
    
    // 更新玩家二的血量（如果存在）
    if (player2) {
        player2.health = currentPlayerMaxHealth;
        player2.maxHealth = currentPlayerMaxHealth;
    }

// 初始化游戏
// There should be only ONE init function

    // 更新敌人生成逻辑以使用调整后的参数
    // 假设 generateEnemy 函数会使用这些全局或可访问的常量
    // 如果 generateEnemy 内部有硬编码的常量，需要修改 generateEnemy 函数

    // 示例：调整敌人生成
    // 这里的逻辑需要根据实际的敌人生成方式进行调整
    // 如果敌人是循环生成的，需要修改生成间隔的变量
    // 如果是初始生成，则在下面生成时使用调整后的血量和速度

    // 玩家对象初始化 (确保在难度调整后)
    player.x = canvas.width / 2 - 25;
    player.y = canvas.height / 2 - 25;
    player.width = 50;
    player.height = 50;
    player.color = 'blue';
    player.health = currentPlayerMaxHealth;
    player.speed = PLAYER_SPEED;
    player.canMove = true; // 确保 canMove 属性被初始化
    player.isAttacking = false;
    player.attackEndTime = 0;
    player.canAttack = true;
    player.rotationAngle = 0; // 初始化旋转角度
    player.attackCooldown = currentPlayerAttackCooldown; // 玩家攻击冷却时间
    player.lastGrenadeThrowTime = 0;
    player.canThrowGrenade = true;
    player.grenadeCooldown = currentGrenadeCooldown; // 手雷冷却时间
    player.lastMinePlacementTime = 0;
    player.canPlaceMine = true;
    player.mineCooldown = currentMineCooldown; // 地雷冷却时间
    player.lastRotateShootTime = 0;
    player.canUseRotateShoot = true;
    player.rotateShootCooldown = currentRotateShootCooldown; // 旋转射击冷却时间
    player.moveUp = false;
    player.moveDown = false;
    player.moveLeft = false;
    player.moveRight = false;
    player.trail = []; // 玩家移动轨迹

    // 清空敌人和子弹
    enemies = [];
    bullets = [];
    purpleEnemyBullets = [];
    redEnemyBullets = [];
    grenades = [];
    mines = [];
    explosions = [];
    
    // 初始化地形区域
    terrainAreas = [];
    if (terrains.length > 0) {
        generateTerrainAreas(terrains);
    }
    
    // 重置地形相关状态
    playerBubbles = { player1: 3, player2: 3 };
    lastBubbleLossTime = { player1: 0, player2: 0 };
    playerInGrass = { player1: false, player2: false };
    grassCooldown = { player1: 0, player2: 0 };
    enemyQuestionMarks = [];

    // 初始生成敌人 (使用调整后的参数)
    if (mode === 'multi') {
        // 双人模式下，任意多个红挂和瓷怪冲向玩家一，其他冲向玩家二
        // 假设一半冲向玩家一，一半冲向玩家二
        const redToPlayer1 = Math.ceil(initialRedEnemies / 2);
        const purpleToPlayer1 = Math.ceil(initialPurpleEnemies / 2);

        for (let i = 0; i < redToPlayer1; i++) {
            generateEnemy('red', player);
        }
        for (let i = 0; i < initialRedEnemies - redToPlayer1; i++) {
            generateEnemy('red', player2);
        }

        for (let i = 0; i < purpleToPlayer1; i++) {
            generateEnemy('purple', player);
        }
        for (let i = 0; i < initialPurpleEnemies - purpleToPlayer1; i++) {
            generateEnemy('purple', player2);
        }
    } else {
        for (let i = 0; i < initialRedEnemies; i++) {
            generateEnemy('red');
        }
        for (let i = 0; i < initialPurpleEnemies; i++) {
            generateEnemy('purple');
        }
    }

    // ... 保持其他不变的初始化逻辑 ...

    // 根据设备类型初始化控制方式
    if (isPC) {
        // 电脑端使用键盘控制 - 移除重复的事件监听器，使用全局的handleKeyDown
    }
    // 设置键盘事件监听
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    // 设置鼠标点击监听
    canvas.addEventListener('click', handleMouseClick);
    
    // 加载README内容
}

// 生成地形区域函数
function generateTerrainAreas(terrains) {
    terrains.forEach(terrainType => {
        let area;
        do {
            area = {
                type: terrainType,
                x: Math.random() * (canvas.width - TERRAIN_AREA_SIZE),
                y: Math.random() * (canvas.height - TERRAIN_AREA_SIZE),
                width: TERRAIN_AREA_SIZE,
                height: TERRAIN_AREA_SIZE
            };
        } while (isOverlapping(area));
        
        terrainAreas.push(area);
    });
}

// 检查地形区域是否重叠
function isOverlapping(newArea) {
    return terrainAreas.some(area => {
        return newArea.x < area.x + area.width &&
               newArea.x + newArea.width > area.x &&
               newArea.y < area.y + area.height &&
               newArea.y + newArea.height > area.y;
    });
}

// 检查玩家是否在特定地形中
function getPlayerTerrain(player) {
    for (let area of terrainAreas) {
        if (player.x < area.x + area.width &&
            player.x + player.width > area.x &&
            player.y < area.y + area.height &&
            player.y + player.height > area.y) {
            return area.type;
        }
    }
    return null;
}

// 检查敌人是否在特定地形中
function getEnemyTerrain(enemy) {
    for (let area of terrainAreas) {
        if (enemy.x < area.x + area.width &&
            enemy.x + enemy.width > area.x &&
            enemy.y < area.y + area.height &&
            enemy.y + enemy.height > area.y) {
            return area.type;
        }
    }
    return null;
}

// 处理地形效果
function handleTerrainEffects() {
    const currentTime = Date.now();
    
    // 处理玩家1地形效果
    handlePlayerTerrainEffects(player, 'player1', currentTime);
    
    // 处理玩家2地形效果（如果存在）
    if (player2) {
        handlePlayerTerrainEffects(player2, 'player2', currentTime);
    }
    
    // 处理敌人地形效果
    enemies.forEach(enemy => {
        handleEnemyTerrainEffects(enemy, currentTime);
    });
}

// 处理玩家地形效果
function handlePlayerTerrainEffects(player, playerId, currentTime) {
    const terrain = getPlayerTerrain(player);
    
    // 重置速度
    let speedMultiplier = 1;
    
    if (terrain) {
        switch (terrain) {
            case 'shallow':
                speedMultiplier = SHALLOW_WATER_SPEED_REDUCTION;
                break;
            case 'deep':
                speedMultiplier = DEEP_WATER_SPEED_REDUCTION;
                // 处理气泡逻辑
                if (currentTime - lastBubbleLossTime[playerId] >= DEEP_WATER_BUBBLE_INTERVAL) {
                    if (playerBubbles[playerId] > 0) {
                        playerBubbles[playerId]--;
                        lastBubbleLossTime[playerId] = currentTime;
                    }
                }
                // 如果没有气泡了，持续扣血
                if (playerBubbles[playerId] === 0) {
                    if (currentTime - lastBubbleLossTime[playerId] >= 1000) {
                        player.health -= DEEP_WATER_DAMAGE;
                        lastBubbleLossTime[playerId] = currentTime;
                    }
                }
                break;
            case 'lava':
                // 岩浆：移动速度大幅减少，持续扣血
                speedMultiplier = 0.2; // 减少80%移动速度
                if (currentTime - (player.lastLavaDamage || 0) >= 1000) {
                    player.health -= LAVA_DAMAGE;
                    player.lastLavaDamage = currentTime;
                }
                break;
            case 'grass':
                // 草丛：检查冷却时间
                if (currentTime - grassCooldown[playerId] >= GRASS_COOLDOWN_TIME) {
                    playerInGrass[playerId] = true;
                    // 设置敌人问号状态
                    enemies.forEach(enemy => {
                        if (!enemy.questionMark && !enemy.isDead) {
                            enemy.questionMark = true;
                            enemy.canShoot = false;
                            enemy.isStunned = true; // 禁用移动
                        }
                    });
                }
                break;
        }
    } else {
        // 离开地形时重置状态
        if (playerInGrass[playerId]) {
            playerInGrass[playerId] = false;
            grassCooldown[playerId] = currentTime;
            // 触发敌人感叹号
            triggerEnemyExclamation();
        }
        // 离开深水时重置气泡
        if (playerBubbles[playerId] < 3) {
            playerBubbles[playerId] = 3;
        }
    }
    
    // 应用速度修正
    player.currentSpeedMultiplier = speedMultiplier;
}

// 处理敌人地形效果
function handleEnemyTerrainEffects(enemy, currentTime) {
    const terrain = getEnemyTerrain(enemy);
    
    if (terrain) {
        switch (terrain) {
            case 'shallow':
                enemy.speedMultiplier = SHALLOW_WATER_SPEED_REDUCTION;
                break;
            case 'deep':
                enemy.speedMultiplier = DEEP_WATER_SPEED_REDUCTION;
                // 敌人进入深水立即扣血
                if (!enemy.inDeepWater) {
                    enemy.health -= DEEP_WATER_DAMAGE;
                    enemy.inDeepWater = true;
                }
                break;
            case 'lava':
                enemy.speedMultiplier = 0.2; // 减少80%移动速度
                if (currentTime - (enemy.lastLavaDamage || 0) >= 1000) {
                    enemy.health -= LAVA_DAMAGE;
                    enemy.lastLavaDamage = currentTime;
                }
                break;
            case 'grass':
                enemy.speedMultiplier = 1;
                break;
        }
    } else {
        enemy.speedMultiplier = 1;
        enemy.inDeepWater = false;
    }
}

// 触发敌人感叹号效果
function triggerEnemyExclamation() {
    enemies.forEach(enemy => {
        if (enemy.questionMark && !enemy.isDead) {
            enemy.questionMark = false;
            enemy.exclamationMark = true;
            enemy.exclamationStartTime = Date.now();
            setTimeout(() => {
                if (!enemy.isDead) {
                    enemy.exclamationMark = false;
                    enemy.canShoot = true;
                    enemy.isStunned = false; // 恢复移动
                }
            }, 1000);
        }
    });
}

// 检查玩家技能使用时是否在草丛中
function checkGrassSkillTrigger(player, playerId) {
    if (playerInGrass[playerId]) {
        triggerEnemyExclamation();
        playerInGrass[playerId] = false;
        grassCooldown[playerId] = Date.now();
    }
}

// 绘制地形区域
function drawTerrainAreas() {
    terrainAreas.forEach(area => {
        ctx.save();
        
        switch (area.type) {
            case 'shallow':
                // 浅水 - 浅蓝色
                ctx.fillStyle = 'rgba(135, 206, 235, 0.6)';
                break;
            case 'deep':
                // 深水 - 深蓝色
                ctx.fillStyle = 'rgba(0, 100, 200, 0.7)';
                break;
            case 'lava':
                // 岩浆 - 红橙色
                ctx.fillStyle = 'rgba(255, 69, 0, 0.8)';
                break;
            case 'grass':
                // 草丛 - 绿色
                ctx.fillStyle = 'rgba(34, 139, 34, 0.6)';
                break;
        }
        
        ctx.fillRect(area.x, area.y, area.width, area.height);
        
        // 绘制边框
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 2;
        ctx.strokeRect(area.x, area.y, area.width, area.height);
        
        ctx.restore();
    });
}

// 绘制玩家气泡（深水效果）
function drawPlayerBubbles(player, playerId) {
    const bubbleCount = playerBubbles[playerId] || 0;
    if (bubbleCount > 0) {
        for (let i = 0; i < bubbleCount; i++) {
            ctx.save();
            ctx.fillStyle = 'rgba(173, 216, 230, 0.8)';
            ctx.beginPath();
            const bubbleX = player.x + player.width / 2 + (i - 1) * 15;
            const bubbleY = player.y - 20 - i * 5;
            ctx.arc(bubbleX, bubbleY, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = 'rgba(0, 100, 200, 0.6)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();
        }
    }
}

// 绘制敌人状态图标（问号/感叹号）
function drawEnemyStatusIcons() {
    enemies.forEach(enemy => {
        if (enemy.questionMark) {
            ctx.save();
            ctx.fillStyle = 'yellow';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('?', enemy.x + enemy.width / 2, enemy.y - 10);
            ctx.restore();
        } else if (enemy.exclamationMark) {
            ctx.save();
            ctx.fillStyle = 'red';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('!', enemy.x + enemy.width / 2, enemy.y - 10);
            ctx.restore();
        }
    });
}


// 鼠标点击事件处理
function handleMouseClick(e) {
    // 获取画布的边界矩形
    const rect = canvas.getBoundingClientRect();
    
    // 计算鼠标在画布中的实际坐标
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // 在双人模式下，根据按键状态判断是哪个玩家进行范围攻击
    if (player2) {
        // 双人模式：检查是否按住了玩家2的控制键
        if (e.shiftKey) {
            // 按住Shift键+鼠标点击 = 玩家2以自身为中心的范围攻击
            activateAreaAttack(player2);
        } else {
            // 普通鼠标点击 = 玩家1以自身为中心的范围攻击
            activateAreaAttack(player);
        }
    } else {
        // 单人模式：鼠标点击不再自动触发手雷，改为范围攻击
        activateAreaAttack(player);
    }
}

// 键盘按下事件处理
function handleKeyDown(e) {
    console.log('Key pressed:', e.key); // 添加日志
    switch(e.key) {
        case 'ArrowUp':
            if (player2) {
                player2.moveUp = true;
            } else {
                // 单人模式下，方向键控制玩家1
                player.moveUp = true;
            }
            break;
        case 'ArrowDown':
            if (player2) {
                player2.moveDown = true;
            } else {
                // 单人模式下，方向键控制玩家1
                player.moveDown = true;
            }
            break;
        case 'ArrowLeft':
            if (player2) {
                player2.moveLeft = true;
            } else {
                // 单人模式下，方向键控制玩家1
                player.moveLeft = true;
            }
            break;
        case 'ArrowRight':
            if (player2) {
                player2.moveRight = true;
            } else {
                // 单人模式下，方向键控制玩家1
                player.moveRight = true;
            }
            break;
        case 'f': // 玩家1地雷 (按照README)
            handlePlayerMine(player);
            break;
        case 'g': // 玩家1旋转射击 (按照README)
            activateRotateShoot(player);
            break;
        case 'q': // 玩家1手雷 (双人模式)
            if (player2) {
                handlePlayerGrenade(player);
            }
            break;
        case 'd': // 玩家1向右移动 (单人和双人模式)
            // D键在单人和双人模式下都控制玩家1向右移动
            player.moveRight = true;
            break;
        case 'e': // 玩家1攻击 (保留原有功能)
            if (player.canAttack) {
                player.isAttacking = true;
                player.attackTimer = 10; // 攻击动画持续时间
                player.canAttack = false;
                setTimeout(() => {
                    player.canAttack = true;
                }, player.attackCooldown);
            }
            break;
        case 'r': // 玩家1瞬间范围攻击 (保留原有功能)
            if (player.canAreaAttack) {
                activateAreaAttack(player);
            }
            break;
        case 't': // 玩家1旋转射击 (保留原有功能)
            activateRotateShoot(player);
            break;
        // Player 1 controls (WASD键在单人和双人模式下都有效)
        case 'w':
            // WASD控制玩家1移动（单人和双人模式都可用）
            player.moveUp = true;
            break;
        case 's':
            // WASD控制玩家1移动（单人和双人模式都可用）
            player.moveDown = true;
            break;
        case 'a':
            // WASD控制玩家1移动（单人和双人模式都可用）
            player.moveLeft = true;
            break;
        // 双人模式下玩家1的移动键位 (按照README)
        case 'i': // 玩家1向上移动 (双人模式)
            if (player2) {
                player.moveUp = true;
            }
            break;
        case 'k': // 玩家1向下移动 (双人模式)
            if (player2) {
                player.moveDown = true;
            }
            break;
        case 'j': // 玩家1向左移动 (双人模式)
            if (player2) {
                player.moveLeft = true;
            }
            break;
        case 'l': // 玩家1向右移动 (双人模式)
            if (player2) {
                player.moveRight = true;
            }
            break;
        case ' ': // 玩家2旋转射击（按照README）
            if (player2) {
                activateRotateShoot(player2);
            } else {
                // 单人模式下，空格键也能控制玩家1旋转射击
                activateRotateShoot(player);
            }
            break;
        case "'": // 玩家2地雷（按照README）
            if (player2) {
                handlePlayerMine(player2);
            } else {
                // 单人模式下，'键也能控制玩家1放置地雷
                handlePlayerMine(player);
            }
            break;
        case ';': // 玩家2手雷（按照README）
            if (player2) {
                handlePlayerGrenade(player2);
            } 
            break;
        case '/': // 玩家2攻击 (保留原有功能)
            if (player2 && player2.canAttack) {
                player2.isAttacking = true;
                player2.attackTimer = 10;
                player2.canAttack = false;
                setTimeout(() => {
                    player2.canAttack = true;
                }, player2.attackCooldown);
            } else if (player.canAttack) {
                // 单人模式下，/键也能控制玩家1攻击
                player.isAttacking = true;
                player.attackTimer = 10;
                player.canAttack = false;
                setTimeout(() => {
                    player.canAttack = true;
                }, player.attackCooldown);
            }
            break;
        case '.': // 玩家2手雷 (保留原有功能)
            if (player2) {
                handlePlayerGrenade(player2);
            } else {
                // 单人模式下，.键也能控制玩家1投掷手雷
                handlePlayerGrenade(player);
            }
            break;
        case ',': // 玩家2瞬间范围攻击 (保留原有功能)
            if (player2 && player2.canAreaAttack) {
                activateAreaAttack(player2);
            } else if (player.canAreaAttack) {
                // 单人模式下，,键也能控制玩家1瞬间范围攻击
                activateAreaAttack(player);
            }
            break;

        case 'Escape': // 返回大厅
            if (gameWinner) {
                returnToLobby();
            }
            break;
    }
}

function handleKeyUp(e) {
    switch(e.key) {
        case 'ArrowUp':
            if (player2) {
                player2.moveUp = false;
            } else {
                // 单人模式下，方向键控制玩家1
                player.moveUp = false;
            }
            break;
        case 'ArrowDown':
            if (player2) {
                player2.moveDown = false;
            } else {
                // 单人模式下，方向键控制玩家1
                player.moveDown = false;
            }
            break;
        case 'ArrowLeft':
            if (player2) {
                player2.moveLeft = false;
            } else {
                // 单人模式下，方向键控制玩家1
                player.moveLeft = false;
            }
            break;
        case 'ArrowRight':
            if (player2) {
                player2.moveRight = false;
            } else {
                // 单人模式下，方向键控制玩家1
                player.moveRight = false;
            }
            break;
        case 'w':
            // WASD控制玩家1移动（单人和双人模式都可用）
            player.moveUp = false;
            break;
        case 's':
            // WASD控制玩家1移动（单人和双人模式都可用）
            player.moveDown = false;
            break;
        case 'a':
            // WASD控制玩家1移动（单人和双人模式都可用）
            player.moveLeft = false;
            break;
        case 'd':
            // D键在单人和双人模式下都控制玩家1向右移动
            player.moveRight = false;
            break;
        // 双人模式下玩家1的移动键位 (按照README)
        case 'i': // 玩家1向上移动 (双人模式)
            if (player2) {
                player.moveUp = false;
            }
            break;
        case 'k': // 玩家1向下移动 (双人模式)
            if (player2) {
                player.moveDown = false;
            }
            break;
        case 'j': // 玩家1向左移动 (双人模式)
            if (player2) {
                player.moveLeft = false;
            }
            break;
        case 'l': // 玩家1向右移动 (双人模式)
            if (player2) {
                player.moveRight = false;
            }
            break;
    }
}

function updatePlayerPosition(p) {
    if (p.canMove) {
        const oldX = p.x;
        const oldY = p.y;
        
        // 应用地形速度修正
        const effectiveSpeed = p.speed * (p.currentSpeedMultiplier || 1);
        
        if (p.moveUp) p.y -= effectiveSpeed;
        if (p.moveDown) p.y += effectiveSpeed;
        if (p.moveLeft) p.x -= effectiveSpeed;
        if (p.moveRight) p.x += effectiveSpeed;

        // 边界检查
        p.x = Math.max(0, Math.min(canvas.width - p.width, p.x));
        p.y = Math.max(0, Math.min(canvas.height - p.height, p.y));
        
        // 如果玩家位置发生了变化，记录轨迹
        if (oldX !== p.x || oldY !== p.y) {
            p.trail.push({
                x: oldX + p.width / 2,
                y: oldY + p.height / 2,
                time: Date.now(),
                alpha: 1.0
            });
            
            // 限制轨迹长度，保持最近的20个位置
            if (p.trail.length > 20) {
                p.trail.shift();
            }
        }
        
        // 更新轨迹透明度
        const currentTime = Date.now();
        p.trail = p.trail.filter(point => {
            const age = currentTime - point.time;
            point.alpha = Math.max(0, 1 - age / 1000); // 1秒内完全消失
            return point.alpha > 0;
        });
    }
}

function handlePlayerGrenade(p, targetX, targetY) {
    const currentTime = Date.now();
    if (!p.canThrowGrenade) {
        const remainingCooldown = Math.ceil((p.lastGrenadeThrowTime + GRENADE_COOLDOWN - currentTime) / 1000);
        if (remainingCooldown > 0) {
            showCooldownMessage('手雷', remainingCooldown);
        }
        return;
    }
    
    // 检查草丛技能触发
    const playerId = p === player ? 'player1' : 'player2';
    checkGrassSkillTrigger(p, playerId);

    // 如果没有提供目标坐标，使用玩家附近的随机位置（用于键盘控制）
    if (targetX === undefined || targetY === undefined) {
        targetX = p.x + p.width / 2 + (Math.random() - 0.5) * 200;
        targetY = p.y + p.height / 2 + (Math.random() - 0.5) * 200;
    }

    const flightTime = GRENADE_MIN_FLIGHT_TIME + Math.random() * (GRENADE_MAX_FLIGHT_TIME - GRENADE_MIN_FLIGHT_TIME);

    const grenade = {
        x: p.x + p.width / 2,
        y: p.y + p.height / 2,
        targetX: targetX,
        targetY: targetY,
        startTime: currentTime,
        flightTime: flightTime,
        radius: 10,
        color: '#3498db',
        damage: GRENADE_DAMAGE,
        explosionRadius: GRENADE_EXPLOSION_RADIUS,
        hasExploded: false,
        owner: p
    };
    grenades.push(grenade);

    p.canThrowGrenade = false;
    p.lastGrenadeThrowTime = currentTime;

    setTimeout(() => {
        p.canThrowGrenade = true;
    }, GRENADE_COOLDOWN);
}

function handlePlayerMine(p) {
    const currentTime = Date.now();
    if (!p.canPlaceMine) {
        const remainingCooldown = Math.ceil((p.lastMinePlaced + MINE_COOLDOWN - currentTime) / 1000);
        if (remainingCooldown > 0) {
            showCooldownMessage('地雷', remainingCooldown);
        }
        return;
    }

    const mine = {
        x: p.x + p.width / 2 - 15,
        y: p.y + p.height / 2 - 15,
        width: 30,
        height: 30,
        radius: 15,
        color: '#f1c40f',
        damage: MINE_DAMAGE,
        explosionRadius: MINE_EXPLOSION_RANGE,
        placedTime: currentTime,
        explodeTime: currentTime + 3000, // 3秒后爆炸
        hasExploded: false,
        explosionTimer: 0,
        isExploding: false,
        damageApplied: false, // 新增属性，标记伤害是否已应用
        owner: p // 添加owner属性，标识地雷的所有者
    };
    mines.push(mine);

    p.canPlaceMine = false;
    p.lastMinePlaced = currentTime;

    setTimeout(() => {
        p.canPlaceMine = true;
    }, MINE_COOLDOWN);
}

function activateAreaAttack(p) {
    const currentTime = Date.now();
    if (!p.canAreaAttack) {
        const remainingCooldown = Math.ceil((p.lastAreaAttackTime + AREA_ATTACK_COOLDOWN - currentTime) / 1000);
        if (remainingCooldown > 0) {
            showCooldownMessage('瞬间范围攻击', remainingCooldown);
        }
        return;
    }

    // 执行范围攻击
    enemies.forEach(enemy => {
        if (!enemy.isDead) {
            const dx = enemy.x + enemy.width / 2 - p.x - p.width / 2;
            const dy = enemy.y + enemy.height / 2 - p.y - p.height / 2;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= AREA_ATTACK_RADIUS) {
                enemy.health -= AREA_ATTACK_DAMAGE;
                if (enemy.health <= 0) {
                    enemy.isDead = true;
                }
            }
        }
    });

    // 对Boss造成范围攻击伤害
    if (boss && !boss.isDead) {
        const dx = boss.x + boss.width / 2 - p.x - p.width / 2;
        const dy = boss.y + boss.height / 2 - p.y - p.height / 2;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance <= AREA_ATTACK_RADIUS) {
            boss.health -= AREA_ATTACK_DAMAGE;
            if (boss.health <= 0) {
                boss.isDead = true;
            }
        }
    }

    // 创建一个临时的爆炸效果来表示范围攻击
    createExplosion(p.x + p.width / 2, p.y + p.height / 2, AREA_ATTACK_RADIUS, 0, p); // 伤害为0，因为伤害已直接计算

    p.canAreaAttack = false;
    p.lastAreaAttackTime = currentTime;

    setTimeout(() => {
        p.canAreaAttack = true;
    }, AREA_ATTACK_COOLDOWN);
}

// 定点范围攻击函数（用于鼠标点击）


function handlePlayerRotateShoot(p) {
    const currentTime = Date.now();
    if (!p.canUseRotateShoot) {
        const remainingCooldown = Math.ceil((p.lastRotateShootTime + ROTATE_SHOOT_COOLDOWN - currentTime) / 1000);
        if (remainingCooldown > 0) {
            showCooldownMessage('旋转射击', remainingCooldown);
        }
        return;
    }

    p.isRotateShooting = true;
    p.rotateShootStartTime = currentTime;
    p.rotateShootEndTime = currentTime + ROTATE_SHOOT_DURATION;
    p.lastBulletTime = currentTime;

    p.canUseRotateShoot = false;
    p.lastRotateShootTime = currentTime;

    setTimeout(() => {
        p.canUseRotateShoot = true;
    }, ROTATE_SHOOT_COOLDOWN);
}

// 更新敌人位置（简单的AI，向玩家移动）
function updateEnemies() {
    
    enemies.forEach(enemy => {
        if (!enemy.isDead) {
            // 简单AI：向玩家移动
            const currentTime = Date.now();

            // 处理敌人眩晕状态
            if (enemy.isStunned) {
                if (currentTime - enemy.stunStartTime >= ENEMY_STUN_DURATION) {
                    enemy.isStunned = false; // 眩晕结束
                }
            }

            // 恢复敌人速度
            if (enemy.originalSpeed && enemy.speedReducedTime && (currentTime - enemy.speedReducedTime >= ENEMY_SPEED_RECOVERY_DURATION)) {
                enemy.speed = enemy.originalSpeed;
                enemy.originalSpeed = null; // 清除原始速度记录
                enemy.speedReducedTime = null;
            }

            if (!enemy.isStunned) {
                const targetPlayer = enemy.targetPlayer; // 获取敌人的目标玩家
                const dx = targetPlayer.x - enemy.x;
                const dy = targetPlayer.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
    
                if (distance > 0) {
                    // 应用地形速度修正
                    const effectiveSpeed = enemy.speed * (enemy.speedMultiplier || 1);
                    enemy.x += (dx / distance) * effectiveSpeed;
                    enemy.y += (dy / distance) * effectiveSpeed;
                }
            }

            // 敌人射击逻辑
            // 游戏开始5秒内敌人不能射击
            const gameElapsedTime = currentTime - gameStartTime;
            if (enemy.type === 'purple') {
                if (gameElapsedTime < 5000) {
                    // 在冷却期内，显示调试信息
                    const remainingCooldown = Math.ceil((5000 - gameElapsedTime) / 1000);
                    if (Math.floor(gameElapsedTime / 1000) !== Math.floor((gameElapsedTime - 16) / 1000)) {
                        console.log(`紫色敌人冷却中，剩余 ${remainingCooldown} 秒`);
                    }
                } else if (currentTime - enemy.lastShootTime >= PURPLE_ENEMY_SHOOT_INTERVAL && enemy.canShoot !== false) {
                    // 选择最近的玩家作为目标
                    let targetPlayer = player;
                    let minDistance = Math.sqrt(Math.pow(player.x - enemy.x, 2) + Math.pow(player.y - enemy.y, 2));
                    
                    if (player2) {
                        const distanceToPlayer2 = Math.sqrt(Math.pow(player2.x - enemy.x, 2) + Math.pow(player2.y - enemy.y, 2));
                        if (distanceToPlayer2 < minDistance) {
                            targetPlayer = player2;
                            minDistance = distanceToPlayer2;
                        }
                    }

                    // 计算射击方向
                    const shootDx = targetPlayer.x - enemy.x;
                    const shootDy = targetPlayer.y - enemy.y;
                    const shootDistance = Math.sqrt(shootDx * shootDx + shootDy * shootDy);

                    if (shootDistance > 0) {
                        // 创建子弹
                        const bullet = {
                            x: enemy.x + enemy.width / 2,
                            y: enemy.y + enemy.height / 2,
                            vx: (shootDx / shootDistance) * PURPLE_ENEMY_BULLET_SPEED,
                            vy: (shootDy / shootDistance) * PURPLE_ENEMY_BULLET_SPEED,
                            radius: 8,
                            damage: PURPLE_ENEMY_BULLET_DAMAGE,
                            color: '#ff00ff' // 亮紫色子弹，更容易看见
                        };
                        purpleEnemyBullets.push(bullet);
                        enemy.lastShootTime = currentTime;
                        console.log('紫色敌人射击！子弹数量:', purpleEnemyBullets.length);
                    }
                }
            } else if (enemy.type === 'red') {
                // 红色敌人射击逻辑
                if (gameElapsedTime >= 3000 && currentTime - enemy.lastShootTime >= RED_ENEMY_SHOOT_INTERVAL && enemy.canShoot !== false) {
                    // 选择最近的玩家作为目标
                    let targetPlayer = player;
                    let minDistance = Math.sqrt(Math.pow(player.x - enemy.x, 2) + Math.pow(player.y - enemy.y, 2));
                    
                    if (player2) {
                        const distanceToPlayer2 = Math.sqrt(Math.pow(player2.x - enemy.x, 2) + Math.pow(player2.y - enemy.y, 2));
                        if (distanceToPlayer2 < minDistance) {
                            targetPlayer = player2;
                            minDistance = distanceToPlayer2;
                        }
                    }

                    // 计算射击方向
                    const shootDx = targetPlayer.x - enemy.x;
                    const shootDy = targetPlayer.y - enemy.y;
                    const shootDistance = Math.sqrt(shootDx * shootDx + shootDy * shootDy);

                    if (shootDistance > 0) {
                        // 创建红色敌人子弹
                        const bullet = {
                            x: enemy.x + enemy.width / 2,
                            y: enemy.y + enemy.height / 2,
                            vx: (shootDx / shootDistance) * 4, // 红色敌人子弹速度稍快
                            vy: (shootDy / shootDistance) * 4,
                            radius: 6,
                            damage: 3, // 红色敌人子弹伤害
                            color: '#ff4444' // 亮红色子弹
                        };
                        redEnemyBullets.push(bullet);
                        enemy.lastShootTime = currentTime;
                        console.log('红色敌人射击！子弹数量:', redEnemyBullets.length);
                    }
                }
            }
            
            // 检测与玩家的碰撞
            if (checkCollision(player, enemy)) {
                const currentTime = Date.now();
                // 敌人每0.3秒攻击一次
                if (!enemy.lastAttackTime || currentTime - enemy.lastAttackTime >= 300) {
                    enemy.lastAttackTime = currentTime;
                    player.health -= 10; // 敌人攻击玩家造成伤害
                    
                    // 敌人攻击时背景闪烁
                    document.body.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                    setTimeout(() => {
                        document.body.style.backgroundColor = 'black';
                    }, 100);
                }
                
                // 玩家死亡检查
                if (player.health <= 0) {
                    gameRunning = false;
                }
            }
            // 检测与玩家2的碰撞
            if (player2 && checkCollision(player2, enemy)) {
                const currentTime = Date.now();
                // 敌人每0.3秒攻击一次
                if (!enemy.lastAttackTimeP2 || currentTime - enemy.lastAttackTimeP2 >= 300) {
                    enemy.lastAttackTimeP2 = currentTime;
                    player2.health -= 10; // 敌人攻击玩家2造成伤害
                    
                    // 敌人攻击时背景闪烁
                    document.body.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
                    setTimeout(() => {
                        document.body.style.backgroundColor = 'black';
                    }, 100);
                }
                
                // 玩家2死亡检查
                if (player2.health <= 0) {
                    // 玩家2死亡，游戏结束或玩家1胜利
                    gameRunning = false;
                    onGameEnd(); // 游戏结束时显示邮箱
                }
            }
        }
    });
}

// 更新紫色敌人子弹
function updatePurpleEnemyBullets() {
    for (let i = purpleEnemyBullets.length - 1; i >= 0; i--) {
        const bullet = purpleEnemyBullets[i];
        
        // 更新子弹位置
        bullet.x += bullet.vx;
        bullet.y += bullet.vy;
        
        // 检查子弹是否超出边界
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
            purpleEnemyBullets.splice(i, 1);
            continue;
        }
        
        // 检查与玩家1的碰撞
        if (checkCircleRectCollision(bullet, player)) {
            console.log('紫色子弹击中玩家1！伤害:', bullet.damage, '玩家血量:', player.health);
            player.health -= bullet.damage; // 扣10滴血
            purpleEnemyBullets.splice(i, 1);
            
            // 创建紫色爆炸效果
            createPurpleExplosion(bullet.x, bullet.y, 25, 0, null);
            console.log('创建紫色爆炸效果');
            
            // 背景闪烁效果
            document.body.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            setTimeout(() => {
                document.body.style.backgroundColor = 'black';
            }, 100);
            
            // 玩家死亡检查
            if (player.health <= 0) {
                gameRunning = false;
            }
            continue;
        }
        
        // 检查与玩家2的碰撞
        if (player2 && checkCircleRectCollision(bullet, player2)) {
            console.log('紫色子弹击中玩家2！伤害:', bullet.damage, '玩家血量:', player2.health);
            player2.health -= bullet.damage; // 扣10滴血
            purpleEnemyBullets.splice(i, 1);
            
            // 创建紫色爆炸效果
            createPurpleExplosion(bullet.x, bullet.y, 25, 0, null);
            console.log('创建紫色爆炸效果');
            
            // 背景闪烁效果
            document.body.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            setTimeout(() => {
                document.body.style.backgroundColor = 'black';
            }, 100);
            
            // 玩家2死亡检查
            if (player2.health <= 0) {
                gameRunning = false;
            }
            continue;
        }
    }
}

// 更新红色敌人子弹
function updateRedEnemyBullets() {
    for (let i = redEnemyBullets.length - 1; i >= 0; i--) {
        const bullet = redEnemyBullets[i];
        
        // 更新子弹位置
        bullet.x += bullet.vx;
        bullet.y += bullet.vy;
        
        // 检查子弹是否超出边界
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
            redEnemyBullets.splice(i, 1);
            continue;
        }
        
        // 检查与玩家1的碰撞
        if (checkCircleRectCollision(bullet, player)) {
            console.log('红色子弹击中玩家1！伤害:', bullet.damage, '玩家血量:', player.health);
            player.health -= bullet.damage; // 扣2滴血
            redEnemyBullets.splice(i, 1);
            
            // 创建红色爆炸效果
            createExplosion(bullet.x, bullet.y, 20, 0, null);
            console.log('创建红色爆炸效果');
            
            // 背景闪烁效果
            document.body.style.backgroundColor = 'rgba(255, 100, 100, 0.2)';
            setTimeout(() => {
                document.body.style.backgroundColor = 'black';
            }, 80);
            
            // 玩家死亡检查
            if (player.health <= 0) {
                gameRunning = false;
            }
            continue;
        }
        
        // 检查与玩家2的碰撞
        if (player2 && checkCircleRectCollision(bullet, player2)) {
            console.log('红色子弹击中玩家2！伤害:', bullet.damage, '玩家血量:', player2.health);
            player2.health -= bullet.damage; // 扣2滴血
            redEnemyBullets.splice(i, 1);
            
            // 创建红色爆炸效果
            createExplosion(bullet.x, bullet.y, 20, 0, null);
            console.log('创建红色爆炸效果');
            
            // 背景闪烁效果
            document.body.style.backgroundColor = 'rgba(255, 100, 100, 0.2)';
            setTimeout(() => {
                document.body.style.backgroundColor = 'black';
            }, 80);
            
            // 玩家2死亡检查
            if (player2.health <= 0) {
                gameRunning = false;
            }
            continue;
        }
    }
}

// 更新Boss状态
function updateBoss() {
    if (!boss || boss.isDead) return;

    const currentTime = Date.now();

    // 检查Boss血量，如果低于20%则加快速度
    const healthPercentage = boss.health / boss.maxHealth;
    let currentSpeed = boss.speed;
    if (healthPercentage <= 0.2) {
        // 血量低于20%时速度翻倍
        if (!boss.originalSpeed) {
            boss.originalSpeed = boss.speed;
        }
        currentSpeed = boss.originalSpeed * 2;
    }

    // Boss 移动 (简单地向玩家移动)
    const dx = player.x - boss.x;
    const dy = player.y - boss.y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance > 0) {
        boss.x += (dx / distance) * currentSpeed;
        boss.y += (dy / distance) * currentSpeed;
    }

    // Boss与玩家1直接碰撞检测
    if (checkCollision(player, boss)) {
        // 连续扣血，每0.1秒扣1血
        if (!player.lastBossTouchTime || currentTime - player.lastBossTouchTime >= 100) {
            player.health -= 1;
            player.lastBossTouchTime = currentTime;
            
            // 玩家死亡检查
            if (player.health <= 0) {
                gameRunning = false;
            }
        }
    }

    // Boss与玩家2直接碰撞检测
    if (player2 && checkCollision(player2, boss)) {
        // 连续扣血，每0.1秒扣1血
        if (!player2.lastBossTouchTime || currentTime - player2.lastBossTouchTime >= 100) {
            player2.health -= 1;
            player2.lastBossTouchTime = currentTime;
            
            // 玩家死亡检查
            if (player2.health <= 0) {
                gameRunning = false;
            }
        }
    }

    // Boss 技能释放
    if (currentTime - boss.lastSkillTime >= BOSS_SKILL_COOLDOWN) {
        boss.shootSkill();
        boss.lastSkillTime = currentTime;
    }

    // 更新Boss子弹
    boss.bullets.forEach((bullet, index) => {
        bullet.x += bullet.vx;
        bullet.y += bullet.vy;

        // 检查子弹是否超出边界
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
            boss.bullets.splice(index, 1);
            return;
        }

        // 检查Boss子弹与玩家1的碰撞
        if (checkCollision(player, bullet)) {
            player.health -= 45; // Boss子弹造成45点伤害
            boss.bullets.splice(index, 1);

            // 创建爆炸效果
            createExplosion(bullet.x, bullet.y, 30, 45, player);

            // 玩家减速至30%
            if (!player.originalSpeed) {
                player.originalSpeed = player.speed;
            }
            player.speed = player.originalSpeed * 0.3;
            player.slowedByBoss = true;
            player.slowEndTime = Date.now() + 10000; // 减速持续10秒

            // 玩家死亡检查
            if (player.health <= 0) {
                gameRunning = false;
            }
            return;
        }

        // 检查Boss子弹与玩家2的碰撞
        if (player2 && checkCollision(player2, bullet)) {
            player2.health -= 45; // Boss子弹造成45点伤害
            boss.bullets.splice(index, 1);

            // 创建爆炸效果
            createExplosion(bullet.x, bullet.y, 30, 45, player2);

            // 玩家减速至30%
            if (!player2.originalSpeed) {
                player2.originalSpeed = player2.speed;
            }
            player2.speed = player2.originalSpeed * 0.3;
            player2.slowedByBoss = true;
            player2.slowEndTime = Date.now() + 10000; // 减速持续10秒

            // 玩家死亡检查
            if (player2.health <= 0) {
                gameRunning = false;
            }
        }
    });

    // 检查Boss是否死亡
    if (boss && boss.health <= 0) {
        boss.isDead = true;
        gameRunning = false; // Boss死亡，游戏结束
        boss = null; // 清除Boss对象
        onGameEnd(); // 游戏结束时显示邮箱
    }
}




// 更新攻击状态
function updateAttackStatus() {
    const currentTime = Date.now();
    
    // 检查攻击持续时间是否结束
    if (player.isAttacking && currentTime >= player.attackEndTime) {
        player.isAttacking = false;
    }
    
    // 检查冷却时间是否结束
    if (!player.canAttack && currentTime >= player.attackEndTime + ATTACK_COOLDOWN) {
        player.canAttack = true;
    }
}

// 攻击敌人和Boss - 现在是持续伤害
function attackEnemies() {
    // 玩家1攻击敌人
    if (player.isAttacking) {
        enemies.forEach(enemy => {
            if (!enemy.isDead) {
                // 计算与玩家1的距离
                const dx = enemy.x - player.x;
                const dy = enemy.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
    
                // 如果在攻击范围内
                if (distance <= ATTACK_RANGE) {
                    // 每帧造成少量伤害（持续伤害）
                    enemy.health -= ATTACK_DAMAGE / 60; // 假设60FPS，每秒总伤害为ATTACK_DAMAGE
                    
                    // 创建爆炸效果（每隔几帧创建一次，避免过多爆炸）
                    if (Math.random() < 0.1) { // 10%概率创建爆炸效果
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    }
                    
                    // 敌人死亡检查
                    if (enemy.health <= 0) {
                        enemy.isDead = true;
                        // 敌人死亡时创建大爆炸
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    }
                }
            }
        });

        // 玩家1攻击Boss
        if (boss && !boss.isDead) {
            const dx = boss.x - player.x;
            const dy = boss.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= ATTACK_RANGE) {
                // 每帧造成少量伤害（持续伤害）
                boss.health -= ATTACK_DAMAGE / 60; // 假设60FPS，每秒总伤害为ATTACK_DAMAGE
                
                // 创建爆炸效果（每隔几帧创建一次，避免过多爆炸）
                if (Math.random() < 0.1) { // 10%概率创建爆炸效果
                    createExplosion(boss.x + boss.width/2, boss.y + boss.height/2);
                }
                
                // Boss死亡检查
                if (boss.health <= 0) {
                    boss.isDead = true;
                    // Boss死亡时创建大爆炸
                    createExplosion(boss.x + boss.width/2, boss.y + boss.height/2);
                }
            }
        }
    }
    
    // 玩家2攻击敌人
    if (player2 && player2.isAttacking) {
        enemies.forEach(enemy => {
            if (!enemy.isDead) {
                // 计算与玩家2的距离
                const dx = enemy.x - player2.x;
                const dy = enemy.y - player2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
    
                // 如果在攻击范围内
                if (distance <= ATTACK_RANGE) {
                    // 每帧造成少量伤害（持续伤害）
                    enemy.health -= ATTACK_DAMAGE / 60; // 假设60FPS，每秒总伤害为ATTACK_DAMAGE
                    
                    // 创建爆炸效果（每隔几帧创建一次，避免过多爆炸）
                    if (Math.random() < 0.1) { // 10%概率创建爆炸效果
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    }
                    
                    // 敌人死亡检查
                    if (enemy.health <= 0) {
                        enemy.isDead = true;
                        // 敌人死亡时创建大爆炸
                        createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                    }
                }
            }
        });

        // 玩家2攻击Boss
        if (boss && !boss.isDead) {
            const dx = boss.x - player2.x;
            const dy = boss.y - player2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= ATTACK_RANGE) {
                // 每帧造成少量伤害（持续伤害）
                boss.health -= ATTACK_DAMAGE / 60; // 假设60FPS，每秒总伤害为ATTACK_DAMAGE
                
                // 创建爆炸效果（每隔几帧创建一次，避免过多爆炸）
                if (Math.random() < 0.1) { // 10%概率创建爆炸效果
                    createExplosion(boss.x + boss.width/2, boss.y + boss.height/2);
                }
                
                // Boss死亡检查
                if (boss.health <= 0) {
                    boss.isDead = true;
                    // Boss死亡时创建大爆炸
                    createExplosion(boss.x + boss.width/2, boss.y + boss.height/2);
                }
            }
        }
    }
}

// 玩家间攻击 - 持续伤害
function attackPlayers() {
    // 只在双人模式下进行玩家间攻击检测
    if (!player2) return;
    
    // 玩家1攻击玩家2
    if (player.isAttacking) {
        const dx = player2.x - player.x;
        const dy = player2.y - player.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= ATTACK_RANGE) {
            // 每帧造成少量伤害（持续伤害）
            player2.health -= ATTACK_DAMAGE / 60; // 假设60FPS，每秒总伤害为ATTACK_DAMAGE
            
            // 玩家2死亡检查
            if (player2.health <= 0) {
                player2.health = 0;
            }
        }
    }
    
    // 玩家2攻击玩家1
    if (player2.isAttacking) {
        const dx = player.x - player2.x;
        const dy = player.y - player2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= ATTACK_RANGE) {
            // 每帧造成少量伤害（持续伤害）
            player.health -= ATTACK_DAMAGE / 60; // 假设60FPS，每秒总伤害为ATTACK_DAMAGE
            
            // 玩家1死亡检查
            if (player.health <= 0) {
                player.health = 0;
            }
        }
    }
}


// 碰撞检测
function checkCollision(rect1, rect2) {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
}

// 检查圆形与矩形的碰撞（用于子弹与玩家的碰撞检测）
function checkCircleRectCollision(circle, rect) {
    // 找到矩形上距离圆心最近的点
    const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
    const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
    
    // 计算距离
    const dx = circle.x - closestX;
    const dy = circle.y - closestY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    return distance <= circle.radius;
}

// 绘制玩家
function drawPlayer(p) {
    // 绘制玩家移动轨迹
    if (p.trail && p.trail.length > 1) {
        ctx.save();
        
        for (let i = 0; i < p.trail.length - 1; i++) {
            const point = p.trail[i];
            const nextPoint = p.trail[i + 1];
            
            // 设置轨迹颜色和透明度
            const trailAlpha = point.alpha * 0.6; // 轨迹比玩家更透明
            ctx.strokeStyle = `rgba(${p.color === 'blue' ? '0, 100, 255' : '255, 215, 0'}, ${trailAlpha})`;
            ctx.lineWidth = 8 * point.alpha; // 轨迹宽度随透明度变化
            ctx.lineCap = 'round';
            
            // 绘制轨迹线段
            ctx.beginPath();
            ctx.moveTo(point.x, point.y);
            ctx.lineTo(nextPoint.x, nextPoint.y);
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    // 绘制玩家角色
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, p.width, p.height);
    
    // 绘制玩家血条
    drawHealthBar(p.x, p.y - 15, p.width, 5, p.health, PLAYER_MAX_HEALTH, '#2ecc71');
    
    // 绘制攻击范围（当攻击时）
    if (p.isAttacking) {
        ctx.beginPath();
        ctx.arc(p.x + p.width/2, p.y + p.height/2, ATTACK_RANGE, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
        ctx.stroke();
        
        p.attackTimer--;
        if (p.attackTimer <= 0) {
            p.isAttacking = false;
        }
    }
}

// 绘制敌人
function drawEnemies() {
    enemies.forEach(enemy => {
        if (!enemy.isDead) {
            // 绘制敌人攻击范围
            ctx.beginPath();
            ctx.arc(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 60, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(231, 76, 60, 0.5)';
            ctx.stroke();
            
            // 绘制敌人
            ctx.fillStyle = enemy.color;
            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            
            // 绘制敌人血条
            drawHealthBar(enemy.x, enemy.y - 10, enemy.width, 5, enemy.health, enemy.maxHealth, '#e74c3c');
        }
    });
}

// 绘制血条
function drawHealthBar(x, y, width, height, health, maxHealth, color) {
    const healthPercentage = Math.max(0, health / maxHealth);
    
    // 血条背景
    ctx.fillStyle = '#333';
    ctx.fillRect(x, y, width, height);
    
    // 血条
    ctx.fillStyle = color;
    ctx.fillRect(x, y, width * healthPercentage, height);
}

// 绘制游戏状态
function drawGameStatus() {
    // 显示玩家血量
    ctx.fillStyle = 'white';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`玩家1 血量: ${Math.floor(player.health)}/${PLAYER_MAX_HEALTH}`, 10, canvas.height - 10);
    if (player2) {
        ctx.fillText(`玩家2 血量: ${Math.floor(player2.health)}/${PLAYER_MAX_HEALTH}`, 10, canvas.height - 30);
    }
    
    // 显示剩余敌人数量
    const aliveEnemies = enemies.filter(enemy => !enemy.isDead).length;
    ctx.fillText(`剩余敌人: ${aliveEnemies}/${enemies.length}`, canvas.width - 150, canvas.height - 10);
    
    // 显示技能状态
    const currentTime = Date.now();
    
    // 普通攻击状态
    let attackStatus = player.canAttack ? '就绪' : 
        `冷却中 (${Math.ceil((player.attackStartTime + ATTACK_DURATION + ATTACK_COOLDOWN - currentTime) / 1000)}秒)`;
    ctx.fillText(`普通攻击: ${attackStatus}`, 10, canvas.height - 35);
    
    // 地雷技能状态
    let mineStatus = player.canPlaceMine ? '就绪' : 
        `冷却中 (${Math.ceil((player.lastMinePlaced + MINE_COOLDOWN - currentTime) / 1000)}秒)`;
    ctx.fillText(`地雷技能: ${mineStatus}`, 10, canvas.height - 60);

    // 手雷技能状态
    let grenadeStatus = player.canThrowGrenade ? '就绪' :
        `冷却中 (${Math.ceil((player.lastGrenadeThrowTime + GRENADE_COOLDOWN - currentTime) / 1000)}秒)`;
    ctx.fillText(`手雷技能: ${grenadeStatus}`, 10, canvas.height - 110);
    
    // 旋转射击技能状态
    let rotateShootStatus = '';
    if (player.canUseRotateShoot) {
        rotateShootStatus = '就绪';
    } else if (player.rotateShootActive) {
        const remainingDuration = Math.ceil((player.rotateShootStartTime + ROTATE_SHOOT_DURATION - currentTime) / 1000);
        if (remainingDuration > 0) {
            rotateShootStatus = `激活中 (${remainingDuration}秒)`;
        } else {
            player.rotateShootActive = false; // 持续时间结束
            rotateShootStatus = '就绪'; // 持续时间结束后立即显示就绪，等待冷却
        }
    } else {
        const remainingCooldown = Math.ceil((player.lastRotateShootTime + ROTATE_SHOOT_DURATION + ROTATE_SHOOT_COOLDOWN - currentTime) / 1000);
        rotateShootStatus = `冷却中 (${remainingCooldown}秒)`;
    }
    ctx.fillText(`旋转射击: ${rotateShootStatus}`, 10, canvas.height - 85);
    

}

// 敌人生成计时

// 生成紫色敌人
function generatePurpleEnemy() {
    const currentTime = Date.now();
    
    // 检查是否达到生成间隔
    if (currentTime - lastPurpleEnemySpawnTime >= PURPLE_ENEMY_SPAWN_INTERVAL) {
        // 根据概率决定是否生成
        if (Math.random() < PURPLE_ENEMY_SPAWN_CHANCE) {
            const enemy = {
                x: Math.random() * (canvas.width - 30),
                y: Math.random() * (canvas.height - 30),
                width: 30,
                height: 30,
                color: '#8e44ad', // 紫色
                health: PURPLE_ENEMY_HEALTH,
                maxHealth: PURPLE_ENEMY_HEALTH,
                speed: PURPLE_ENEMY_SPEED,
                isDead: false,
                type: 'purple', // 标记为紫色敌人
                lastShootTime: 0 // 上次射击时间
            };
            enemies.push(enemy);
        }
        
        // 更新最后生成时间
        lastPurpleEnemySpawnTime = currentTime;
    }
}

// 生成红色敌人
function generateRedEnemy() {
    const currentTime = Date.now();
    
    // 检查是否达到生成间隔
    if (currentTime - lastRedEnemySpawnTime >= RED_ENEMY_SPAWN_INTERVAL) {
        // 根据概率决定是否生成
        if (Math.random() < RED_ENEMY_SPAWN_CHANCE) {
            const enemy = {
                x: Math.random() * (canvas.width - 30),
                y: Math.random() * (canvas.height - 30),
                width: 30,
                height: 30,
                color: '#e74c3c', // 红色
                health: RED_ENEMY_HEALTH,
                maxHealth: RED_ENEMY_HEALTH,
                speed: RED_ENEMY_SPEED,
                isDead: false
            };
            enemies.push(enemy);
        }
        
        // 更新最后生成时间
        lastRedEnemySpawnTime = currentTime;
    }
}

// 激活旋转射击技能 (开始充能)
function activateRotateShoot(p) {
    console.log('activateRotateShoot called'); // 添加日志
    const currentTime = Date.now();

    // 检查是否在冷却中
    if (!p.canUseRotateShoot) {
        const remainingCooldown = Math.ceil((p.lastRotateShootTime + ROTATE_SHOOT_COOLDOWN - currentTime) / 1000);
        if (remainingCooldown > 0) {
            showCooldownMessage('旋转射击', remainingCooldown);
        }
        return;
    }
    
    // 检查草丛技能触发
    const playerId = p === player ? 'player1' : 'player2';
    checkGrassSkillTrigger(p, playerId);

    // 直接激活旋转射击，不进行充能
    p.isChargingRotateShoot = false; // 确保充能状态为false
    launchRotateShoot(p);

    // 旋转射击激活时，玩家速度降为30%
    p.speed = PLAYER_SPEED * 0.3;
    p.rotateShootActive = true;
    // 旋转射击时玩家可以移动，但速度降低

    // 技能结束后恢复原速
    setTimeout(() => {
        p.speed = PLAYER_SPEED;
    }, ROTATE_SHOOT_DURATION);
    p.rotateShootStartTime = currentTime;
    showCooldownMessage('旋转射击', '已激活');
}



// 发射引力炸弹
// 发射旋转射击
function launchRotateShoot(p) {
    p.canUseRotateShoot = false;
    p.lastRotateShootTime = Date.now();

    let bulletsFired = 0;
    const totalBullets = ROTATE_SHOOT_DURATION / ROTATE_SHOOT_INTERVAL;

    const shootInterval = setInterval(() => {
        if (bulletsFired < totalBullets) {
            createBullet(p);
            bulletsFired++;
        } else {
            clearInterval(shootInterval);
        }
    }, ROTATE_SHOOT_INTERVAL);

    // 设置冷却，在技能持续时间结束后开始计算
    setTimeout(() => {
        p.canUseRotateShoot = true;
    }, ROTATE_SHOOT_DURATION + ROTATE_SHOOT_COOLDOWN);
}



// 创建子弹（保留原有功能）
function createBullet(p) {
    const centerX = p.x + p.width / 2;
    const centerY = p.y + p.height / 2;
    
    // 计算子弹方向（基于当前旋转角度）
    const directionX = Math.cos(p.rotationAngle);
    const directionY = -Math.sin(p.rotationAngle);
    
    // 创建新子弹
    const bullet = {
        x: centerX,
        y: centerY,
        radius: ROTATE_SHOOT_RADIUS,
        directionX: directionX,
        directionY: directionY,
        speed: ROTATE_SHOOT_SPEED,
        damage: ROTATE_SHOOT_DAMAGE,
        hasHit: false,
        color: '#f39c12', // 子弹颜色
        isRotateShootBullet: true,
        owner: p // 添加子弹的拥有者
    };
    
    // 添加到子弹数组
    bullets.push(bullet);
    
    // 更新旋转角度（每次发射后旋转）
    p.rotationAngle += Math.PI / 8; // 每次旋转45度
    if (p.rotationAngle >= Math.PI * 2) {
        p.rotationAngle = 0; // 重置为0当完成一圈
    }
}

// 按指定方向创建子弹
function createBulletInDirection(p, angle) {
    const centerX = p.x + p.width / 2;
    const centerY = p.y + p.height / 2;
    
    // 计算子弹方向
    const directionX = Math.cos(angle);
    const directionY = Math.sin(angle);
    
    // 创建新子弹
    const bullet = {
        x: centerX,
        y: centerY,
        radius: ROTATE_SHOOT_RADIUS,
        directionX: directionX,
        directionY: directionY,
        speed: ROTATE_SHOOT_SPEED,
        damage: ROTATE_SHOOT_DAMAGE,
        hasHit: false,
        color: '#f39c12', // 子弹颜色
        isRotateShootBullet: true,
        owner: p // 添加子弹的拥有者
    };
    
    // 添加到子弹数组
    bullets.push(bullet);
}

// 更新子弹位置和检测碰撞
function updateRotateShootStatus(p) {
    if (!p.rotateShootActive) return;

    const currentTime = Date.now();
    if (currentTime >= p.rotateShootStartTime + ROTATE_SHOOT_DURATION) {
        p.rotateShootActive = false;
        p.speed = PLAYER_SPEED; // 恢复玩家速度
        return;
    }
}

function updateBullets(p) {
    for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        // 只处理属于当前玩家的子弹
        if (bullet.owner !== p) continue;

        // 更新子弹位置
        bullet.x += bullet.directionX * bullet.speed;
        bullet.y += bullet.directionY * bullet.speed;
        
        // 检查是否超出画布边界
        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
            bullets.splice(i, 1);
            continue;
        }
        
        // 检测与Boss的碰撞
        if (boss && !boss.isDead) {
            const closestX = Math.max(boss.x, Math.min(bullet.x, boss.x + boss.width));
            const closestY = Math.max(boss.y, Math.min(bullet.y, boss.y + boss.height));
            
            const distanceX = bullet.x - closestX;
            const distanceY = bullet.y - closestY;
            const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
            
            if (distance < ROTATE_SHOOT_RADIUS) {
                // 子弹击中Boss
                boss.health -= 15;
                
                // 创建爆炸效果
                createExplosion(bullet.x, bullet.y);
                
                // 检查Boss是否死亡
                if (boss.health <= 0) {
                    boss.isDead = true;
                }
                
                bullets.splice(i, 1); // 击中后立即移除子弹
                continue;
            }
        }

        // 检测与敌人的碰撞
        let hasHitEnemy = false;
        for (let j = 0; j < enemies.length; j++) {
            const enemy = enemies[j];
            if (!enemy.isDead) {
                // 简单的圆形与矩形碰撞检测
                const closestX = Math.max(enemy.x, Math.min(bullet.x, enemy.x + enemy.width));
                const closestY = Math.max(enemy.y, Math.min(bullet.y, enemy.y + enemy.height));
                
                const distanceX = bullet.x - closestX;
                const distanceY = bullet.y - closestY;
                const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                
                if (distance < ROTATE_SHOOT_RADIUS) {
                    // 子弹击中敌人
                    enemy.health -= ROTATE_SHOOT_DAMAGE;

                    // 如果是旋转射击子弹，让敌人后退10像素
                    if (bullet.isRotateShootBullet) {
                        const knockbackDistance = 10;
                        enemy.x -= bullet.directionX * knockbackDistance;
                        enemy.y -= bullet.directionY * knockbackDistance;

                        // 确保敌人不会移出画布
                        enemy.x = Math.max(0, Math.min(canvas.width - enemy.width, enemy.x));
                        enemy.y = Math.max(0, Math.min(canvas.height - enemy.height, enemy.y));

                        // 敌人速度降到原来的百分之三十
                        if (!enemy.originalSpeed) {
                            enemy.originalSpeed = enemy.speed; // 存储原始速度
                        }
                        enemy.speed = enemy.originalSpeed * 0.3; // 降低速度
                        enemy.speedReducedTime = Date.now(); // 记录速度降低的时间

                        // 敌人持续扣血，直到血量低于50%
                        if (enemy.health > enemy.maxHealth * 0.5) {
                            enemy.isBleeding = true;
                            enemy.bleedDamage = bullet.damage / 5; // 每次扣血量，可以调整
                            enemy.bleedInterval = 500; // 每0.5秒扣血一次
                            enemy.lastBleedTime = Date.now();
                        } else {
                            enemy.isBleeding = false;
                        }
                    }

                    // 检查敌人是否死亡
                    if (enemy.health <= 0) {
                        enemy.isDead = true;
                    }

                    // 创建爆炸效果
                    createExplosion(bullet.x, bullet.y);

                    // 如果是旋转射击的子弹，使敌人停止移动并持续扣血
                    if (bullet.isRotateShootBullet) {
                        enemy.isStunned = true;
                        enemy.stunStartTime = Date.now();
                    }

                    hasHitEnemy = true;
                    bullets.splice(i, 1); // 击中后立即移除子弹
                    break;
                }
            }
        }
    }
}

// 绘制子弹
function drawBullets() {
    bullets.forEach(bullet => {
        ctx.fillStyle = bullet.color || '#f39c12'; // 橙色子弹，如果子弹没有颜色属性则默认为橙色
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, ROTATE_SHOOT_RADIUS, 0, Math.PI * 2);
        ctx.fill();
    });

    // 绘制Boss子弹
    if (boss && boss.bullets) {
        boss.bullets.forEach(bullet => {
            ctx.fillStyle = bullet.color;
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    // 绘制紫色敌人子弹
    purpleEnemyBullets.forEach(bullet => {
        // 添加发光效果
        ctx.save();
        ctx.shadowColor = bullet.color;
        ctx.shadowBlur = 15;
        ctx.fillStyle = bullet.color;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // 绘制白色内核
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.radius * 0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });

    // 绘制红色敌人子弹
    redEnemyBullets.forEach(bullet => {
        // 添加发光效果
        ctx.save();
        ctx.shadowColor = bullet.color;
        ctx.shadowBlur = 12;
        ctx.fillStyle = bullet.color;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // 绘制白色内核
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.radius * 0.3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    });
}





// 创建爆炸效果
function createExplosion(x, y, radius = EXPLOSION_MAX_RADIUS, damage = 0, owner = null) {
    const explosion = {
        x: x,
        y: y,
        radius: 5, // 初始半径
        maxRadius: radius,
        duration: EXPLOSION_DURATION,
        timer: EXPLOSION_DURATION, // 倒计时
        colors: ['#ff0000', '#ff7700', '#ffff00'], // 爆炸颜色渐变（红->橙->黄）
        damage: damage,
        owner: owner, // 添加爆炸的拥有者
        particles: [] // 添加粒子系统
    };
    
    // 创建爆炸粒子
    for (let i = 0; i < EXPLOSION_PARTICLES; i++) {
        const angle = (Math.PI * 2 * i) / EXPLOSION_PARTICLES;
        const speed = Math.random() * 4 + 3;
        explosion.particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: EXPLOSION_DURATION,
            maxLife: EXPLOSION_DURATION,
            size: Math.random() * 3 + 2
        });
    }
    
    // 添加到爆炸效果数组
    explosions.push(explosion);
}

// 创建紫色爆炸效果
function createPurpleExplosion(x, y, radius = EXPLOSION_MAX_RADIUS, damage = 0, owner = null) {
    const explosion = {
        x: x,
        y: y,
        radius: 5, // 初始半径
        maxRadius: radius,
        duration: EXPLOSION_DURATION,
        timer: EXPLOSION_DURATION, // 倒计时
        colors: ['#8B00FF', '#9932CC', '#DA70D6'], // 紫色爆炸颜色渐变（深紫->中紫->浅紫）
        damage: damage,
        owner: owner // 添加爆炸的拥有者
    };
    
    // 添加到爆炸效果数组
    explosions.push(explosion);
    console.log('紫色爆炸已创建！位置:', x, y, '爆炸数组长度:', explosions.length);
}

// 更新爆炸效果
function updateExplosions(p) {
    for (let i = explosions.length - 1; i >= 0; i--) {
        const explosion = explosions[i];
        // 只处理属于当前玩家的爆炸，公共爆炸由updatePublicExplosions处理
        if (explosion.owner !== p) continue;
        
        // 更新计时器
        explosion.timer--;
        
        // 计算当前半径（随时间增大然后缩小）
        const progress = 1 - (explosion.timer / explosion.duration);
        explosion.radius = explosion.maxRadius * Math.sin(progress * Math.PI);
        
        // 更新粒子
        if (explosion.particles) {
            for (let j = explosion.particles.length - 1; j >= 0; j--) {
                const particle = explosion.particles[j];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                particle.vx *= 0.98; // 粒子减速
                particle.vy *= 0.98;
                
                if (particle.life <= 0) {
                    explosion.particles.splice(j, 1);
                }
            }
        }
        
        // 如果计时器结束，移除爆炸效果
        if (explosion.timer <= 0) {
            // 如果爆炸有伤害，则对敌人和Boss造成伤害
            if (explosion.damage > 0) {
                // 对敌人造成伤害
                enemies.forEach(enemy => {
                    if (!enemy.isDead) {
                        const dx = enemy.x + enemy.width / 2 - explosion.x;
                        const dy = enemy.y + enemy.height / 2 - explosion.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance <= explosion.maxRadius) {
                            enemy.health -= explosion.damage;
                            if (enemy.health <= 0) {
                                enemy.isDead = true;
                            }
                        }
                    }
                });

                // 对Boss造成伤害
                if (boss && !boss.isDead) {
                    const dx = boss.x + boss.width / 2 - explosion.x;
                    const dy = boss.y + boss.height / 2 - explosion.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance <= explosion.maxRadius) {
                        boss.health -= explosion.damage;
                        if (boss.health <= 0) {
                            boss.isDead = true;
                        }
                    }
                }
            }
            explosions.splice(i, 1);
        }
    }
}

// 更新公共爆炸效果（owner为null的爆炸）
function updatePublicExplosions() {
    for (let i = explosions.length - 1; i >= 0; i--) {
        const explosion = explosions[i];
        // 只处理公共爆炸（owner为null）
        if (explosion.owner !== null) continue;
        
        // 更新计时器
        explosion.timer--;
        
        // 计算当前半径（随时间增大然后缩小）
        const progress = 1 - (explosion.timer / explosion.duration);
        explosion.radius = explosion.maxRadius * Math.sin(progress * Math.PI);
        
        // 更新粒子
        if (explosion.particles) {
            for (let j = explosion.particles.length - 1; j >= 0; j--) {
                const particle = explosion.particles[j];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                particle.vx *= 0.98; // 粒子减速
                particle.vy *= 0.98;
                
                if (particle.life <= 0) {
                    explosion.particles.splice(j, 1);
                }
            }
        }
        
        // 如果计时器结束，移除爆炸效果
        if (explosion.timer <= 0) {
            explosions.splice(i, 1);
        }
    }
}

// 绘制爆炸效果
function drawExplosions(p) {
    explosions.forEach(explosion => {
        if (explosion.owner !== p && explosion.owner !== null) return;
        
        // 计算当前颜色（基于剩余时间）
        const colorIndex = Math.floor((1 - explosion.timer / explosion.duration) * explosion.colors.length);
        const color = explosion.colors[Math.min(colorIndex, explosion.colors.length - 1)];
        const alpha = explosion.timer / explosion.duration;
        
        // 绘制主爆炸圆形（增强效果）
        ctx.save();
        ctx.shadowColor = color;
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.globalAlpha = alpha * 0.8;
        ctx.fill();
        
        // 绘制内核
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(explosion.x, explosion.y, explosion.radius * 0.6, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = alpha;
        ctx.fill();
        
        // 绘制粒子
        if (explosion.particles) {
            explosion.particles.forEach(particle => {
                const particleAlpha = particle.life / particle.maxLife;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.globalAlpha = particleAlpha * 0.7;
                ctx.fill();
            });
        }
        
        ctx.restore();
    });
}

// 更新敌人生成逻辑
// 检查Boss生成
function checkBossSpawn() {
    if (boss) return; // 如果Boss已经存在，则不生成新的Boss

    const currentTime = Date.now();
    const elapsedTime = currentTime - gameStartTime;

    // 游戏开始30秒后，每30秒检查一次Boss生成
    // 第一次检查：游戏开始30秒后
    // 后续检查：距离上次检查30秒后
    if (elapsedTime >= BOSS_SPAWN_TIME && 
        (lastBossSpawnCheckTime === 0 || currentTime - lastBossSpawnCheckTime >= BOSS_SPAWN_TIME)) {
        lastBossSpawnCheckTime = currentTime;
        if (Math.random() < BOSS_SPAWN_CHANCE) {
            // 生成Boss
            boss = {
                x: canvas.width / 2 - 50, // 初始位置在画布中央
                y: canvas.height / 2 - 50,
                width: 100,
                height: 100,
                color: 'purple',
                health: BOSS_MAX_HEALTH,
                maxHealth: BOSS_MAX_HEALTH,
                speed: BOSS_SPEED,
                isDead: false,
                lastSkillTime: 0, // 上次释放技能时间
                bullets: [], // Boss发射的子弹
                draw: function() {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);

                    // 绘制血条
                    const healthBarWidth = this.width;
                    const healthBarHeight = 10;
                    const healthBarX = this.x;
                    const healthBarY = this.y - 15;
                    ctx.fillStyle = 'gray';
                    ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(healthBarX, healthBarY, healthBarWidth * (this.health / this.maxHealth), healthBarHeight);
                },
                shootSkill: function() {
                    let waveCount = 0;
                    const shootInterval = setInterval(() => {
                        if (waveCount >= BOSS_BULLET_WAVES) {
                            clearInterval(shootInterval);
                            return;
                        }
                        const numBullets = BOSS_BULLET_COUNT;
                        const angleStep = (Math.PI * 2) / numBullets;
                        for (let i = 0; i < numBullets; i++) {
                            const angle = i * angleStep;
                            this.bullets.push({
                                x: this.x + this.width / 2,
                                y: this.y + this.height / 2,
                                vx: Math.cos(angle) * BOSS_BULLET_SPEED,
                                vy: Math.sin(angle) * BOSS_BULLET_SPEED,
                                radius: 8,
                                color: 'orange'
                            });
                        }
                        waveCount++;
                    }, 100); // 每100毫秒发射一波
                }
            };
            // 清除所有小怪
            enemies = [];
        }
    }
}

// 更新敌人生成逻辑
function updateEnemySpawns() {
    // 如果Boss存在，则不生成其他敌人
    if (boss && !boss.isDead) {
        return;
    }
    
    const currentTime = Date.now();

    // 生成紫色敌人
    if (currentTime - lastPurpleEnemySpawnTime >= PURPLE_ENEMY_SPAWN_INTERVAL) {
        if (Math.random() < PURPLE_ENEMY_SPAWN_CHANCE) {
            generateEnemy('purple');
        }
        lastPurpleEnemySpawnTime = currentTime;
    }

    // 生成红色敌人
    if (currentTime - lastRedEnemySpawnTime >= RED_ENEMY_SPAWN_INTERVAL) {
        if (Math.random() < RED_ENEMY_SPAWN_CHANCE) {
            generateEnemy('red');
        }
        lastRedEnemySpawnTime = currentTime;
    }
}

// 游戏循环
function gameLoop() {
    // 清空画布
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (gameRunning) {
        // 更新游戏状态
        updatePlayerPosition(player);
        if (player2) {
            updatePlayerPosition(player2);
        }
        
        // 检查玩家减速状态恢复
        const currentTime = Date.now();
        if (player.slowedByBoss && currentTime >= player.slowEndTime) {
            player.speed = player.originalSpeed;
            player.slowedByBoss = false;
        }
        if (player2 && player2.slowedByBoss && currentTime >= player2.slowEndTime) {
            player2.speed = player2.originalSpeed;
            player2.slowedByBoss = false;
        }
        
        updateEnemies();
        updatePurpleEnemyBullets(); // 更新紫色敌人子弹
        updateRedEnemyBullets(); // 更新红色敌人子弹
        updateMines();
        
        // 处理地形效果
        handleTerrainEffects();

        // 处理敌人持续扣血
        enemies.forEach(enemy => {
            if (enemy.isBleeding && !enemy.isDead) {
                const currentTime = Date.now();
                if (currentTime - enemy.lastBleedTime >= enemy.bleedInterval) {
                    if (enemy.health > enemy.maxHealth * 0.5) {
                        enemy.health -= enemy.bleedDamage;
                        enemy.lastBleedTime = currentTime;
                    } else {
                        enemy.isBleeding = false; // 血量低于50%时停止流血
                    }
                    if (enemy.health <= 0) {
                        enemy.isDead = true;
                        enemy.isBleeding = false; // 敌人死亡后停止流血
                    }
                }
            }
        });

    updateRotateShootStatus(player);
    if (player2) {
        updateRotateShootStatus(player2);
    }
    updateBullets(player);
    if (player2) {
        updateBullets(player2);
    }
    updateGrenades(player);
    updateExplosions(player);
    if (player2) {
        updateGrenades(player2);
        updateExplosions(player2);
    }
    updatePublicExplosions(); // 更新公共爆炸效果
    // 只在决赛圈未激活时生成敌人和Boss
    if (!finalCircleActive) {
        updateEnemySpawns(); // 更新敌人生成逻辑
        checkBossSpawn(); // 检查Boss生成
    }
    if (boss) {
        updateBoss(); // 更新Boss状态
        boss.draw(); // 绘制Boss
    }
    attackEnemies();
    attackPlayers(); // 检测玩家间攻击
    
    // 更新决赛圈
    if (finalCircleActive) {
        updateFinalCircle();
    }
    
    // 检查玩家PVP碰撞（仅在决赛圈激活时）
    if (finalCircleActive && player2) {
        checkPlayerPVP();
    }
    

        
        // 检查游戏是否结束（所有敌人都被击败）
        if (enemies.every(enemy => enemy.isDead) && (!boss || boss.isDead)) {
            // 单人模式直接结束游戏
            if (!player2) {
                gameRunning = false;
                gameWinner = '你存活下来了！';
                // 停止游戏音乐
                const gameMusic = document.getElementById('gameMusic');
                if (gameMusic) {
                    gameMusic.pause();
                }
                // 播放大厅音乐
                const bgMusic = document.getElementById('backgroundMusic');
                if (bgMusic) {
                    bgMusic.play();
                }
            } else {
                // 双人模式启动决赛圈
                if (!finalCircleActive && !finalBattleStarted) {
                    startFinalCircle();
                }
            }
        }
        
        // 检查双人模式下的获胜条件
        if (player2) {
            if (player.health <= 0 && player2.health > 0) {
                gameRunning = false;
                gameWinner = "玩家2";
                console.log("玩家1死亡，玩家2获胜！");
            } else if (player2.health <= 0 && player.health > 0) {
                gameRunning = false;
                gameWinner = "玩家1";
                console.log("玩家2死亡，玩家1获胜！");
            } else if (player.health <= 0 && player2.health <= 0) {
                gameRunning = false;
                gameWinner = "平局";
                console.log("双方同时死亡，平局！");
            }
        } else {
            // 单人模式下玩家死亡
            if (player.health <= 0) {
                gameRunning = false;
                gameWinner = "你被干掉了！";
                console.log("玩家死亡，游戏结束！");
                onGameEnd(); // 游戏结束时显示邮箱
            }
        }
    }
    
    // 绘制游戏元素
    drawTerrainAreas(); // 绘制地形区域
    drawPlayer(player);
    drawPlayerBubbles(player, 'player1'); // 绘制玩家1气泡
    if (player2) {
        drawPlayer(player2);
        drawPlayerBubbles(player2, 'player2'); // 绘制玩家2气泡
    }
    drawEnemies();
    drawEnemyStatusIcons(); // 绘制敌人状态图标
    drawMines();
    drawBullets();
    drawGrenades(player);
    if (player2) {
        drawGrenades(player2);
    }
    drawExplosions(player); // 绘制爆炸效果
    if (player2) {
        drawExplosions(player2);
    }
    drawGameStatus();
    
    // 绘制决赛圈
    if (finalCircleActive) {
        drawFinalCircle();
    }
    
    // 绘制获胜信息
    if (gameWinner) {
        drawVictoryMessage();
    }
    
    // 当玩家血量低于三分之一时绘制红色光晕
    if (player.health < player.maxHealth / 3) {
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = 'red';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
    }
    
    // 继续下一帧
    requestAnimationFrame(gameLoop);
}

// 放置地雷
function placeMine() {
    const currentTime = Date.now();
    
    // 检查是否在冷却中
    if (!player.canPlaceMine) {
        // 计算剩余冷却时间
        const remainingCooldown = Math.ceil((player.lastMinePlaced + MINE_COOLDOWN - currentTime) / 1000);
        
        // 显示冷却提示
        showCooldownMessage('地雷', remainingCooldown);
        return;
    }
    
    // 创建新地雷
    const mine = {
        x: player.x + player.width / 2 - 15, // 居中放置
        y: player.y + player.height / 2 - 15,
        width: 30,
        height: 30,
        placedTime: currentTime,
        explodeTime: currentTime + 3000, // 3秒后爆炸
        hasExploded: false,
        explosionTimer: 0,
        isExploding: false,
        damageApplied: false // 新增属性，标记伤害是否已应用
    };
    
    // 添加到地雷数组
    mines.push(mine);
    
    // 设置冷却
    player.canPlaceMine = false;
    player.lastMinePlaced = currentTime;
    
    // 设置冷却结束后的回调
    setTimeout(() => {
        player.canPlaceMine = true;
    }, MINE_COOLDOWN);
}

// 更新手雷状态
function updateGrenades(p) {
    const currentTime = Date.now();

    for (let i = grenades.length - 1; i >= 0; i--) {
        const grenade = grenades[i];
        // 只处理属于当前玩家的手雷
        if (grenade.owner !== p) continue;

        // 计算手雷飞行进度 (0.0 到 1.0)
        const progress = (currentTime - grenade.startTime) / grenade.flightTime;

        if (progress < 1) {
            // 抛物线运动
            // 使用二次贝塞尔曲线模拟抛物线
            const startX = grenade.x;
            const startY = grenade.y;
            const endX = grenade.targetX;
            const endY = grenade.targetY;

            // 控制点，用于模拟抛物线的高度
            const controlX = (startX + endX) / 2;
            // 根据水平距离调整抛物线顶点高度，距离越远，抛得越高
            const distanceX = Math.abs(endX - startX);
            const distanceY = Math.abs(endY - startY);
            const maxDistance = Math.max(distanceX, distanceY);
            // 调整抛物线顶点高度，使其更合理地落在目标点
            const controlY = (startY + endY) / 2 - Math.max(100, maxDistance / 4);

            grenade.currentX = (1 - progress) * (1 - progress) * startX +
                               2 * (1 - progress) * progress * controlX +
                               progress * progress * endX;
            grenade.currentY = (1 - progress) * (1 - progress) * startY +
                               2 * (1 - progress) * progress * controlY +
                               progress * progress * endY;
        } else {
            // 到达目标点，触发爆炸
            if (!grenade.hasExploded) {
                createExplosion(grenade.targetX, grenade.targetY, grenade.explosionRadius, grenade.damage, p);
                grenade.hasExploded = true;
            }
            // 爆炸后移除手雷
            grenades.splice(i, 1);
        }
    }
}



// 更新地雷状态
function updateMines() 
{
    const currentTime = Date.now();
    
    for (let i = mines.length - 1; i >= 0; i--) {
        const mine = mines[i];
        // 检查是否已爆炸
        // 检查是否与敌人碰撞
        for (let j = 0; j < enemies.length; j++) {
            const enemy = enemies[j];
            if (!enemy.isDead && checkCollision(mine, enemy) && !mine.hasExploded) {
                // 设置0.5秒后爆炸
                mine.explodeTime = currentTime + 500;
                mine.hasExploded = true;
            }
        }
        
        // 检查是否与Boss碰撞
        if (boss && !boss.isDead && checkCollision(mine, boss) && !mine.hasExploded) {
            // 设置0.5秒后爆炸
            mine.explodeTime = currentTime + 500;
            mine.hasExploded = true;
        }
        
        // 检查地雷是否已触发爆炸，爆炸时间已到，且伤害尚未应用
        if (mine.hasExploded && currentTime >= mine.explodeTime && !mine.damageApplied) {
            explodeMine(mine); // 应用伤害
            mine.damageApplied = true; // 标记伤害已应用

            mine.isExploding = true; // 进入爆炸动画状态
            mine.explosionTimer = 20; // 爆炸动画持续时间
        }
        
        // 更新爆炸动画
        if (mine.isExploding) {
            mine.explosionTimer--;
            // 0.1秒后（即爆炸动画开始后6帧，explosionTimer从20减到14）立即消失
            if (mine.explosionTimer <= 14) {
                mine.isExploding = false; // 动画结束
                // 立即移除地雷
                const index = mines.indexOf(mine);
                if (index !== -1) {
                    mines.splice(index, 1);
                }
            }
        }
        
        // 更新爆炸动画
        if (mine.isExploding) {
            mine.explosionTimer--;
            if (mine.explosionTimer <= 0) {
                mine.isExploding = false; // Animation finished
            }
        }
    }
}

// 地雷爆炸逻辑
function explodeMine(mine) {
    // 创建爆炸效果（与手雷相同的爆炸效果）
    createExplosion(mine.x + mine.width/2, mine.y + mine.height/2, MINE_EXPLOSION_RANGE, 0, player);
    
    // 对敌人造成伤害
    enemies.forEach(enemy => {
        if (!enemy.isDead) {
            // 计算与地雷的距离
            const dx = enemy.x + enemy.width/2 - (mine.x + mine.width/2);
            const dy = enemy.y + enemy.height/2 - (mine.y + mine.height/2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // 如果在爆炸范围内
            if (distance <= MINE_EXPLOSION_RANGE) {
                enemy.health -= MINE_DAMAGE;
                
                // 敌人死亡检查
                if (enemy.health <= 0) {
                    enemy.isDead = true;
                }
            }
        }
    });
    
    // 对Boss造成伤害
    if (boss && !boss.isDead) {
        // 计算与地雷的距离
        const dx = boss.x + boss.width/2 - (mine.x + mine.width/2);
        const dy = boss.y + boss.height/2 - (mine.y + mine.height/2);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // 如果在爆炸范围内
        if (distance <= MINE_EXPLOSION_RANGE) {
            boss.health -= MINE_DAMAGE;
            
            // Boss死亡检查
            if (boss.health <= 0) {
                boss.isDead = true;
                gameRunning = false; // Boss死亡，游戏结束
                boss = null; // 清除Boss对象
                onGameEnd(); // 游戏结束时显示邮箱
            }
        }
    }
}

// 绘制手雷
function drawGrenades(p) {
    grenades.forEach(grenade => {
        if (grenade.owner !== p) return;
        ctx.beginPath();
        ctx.arc(grenade.currentX, grenade.currentY, grenade.radius, 0, Math.PI * 2);
        ctx.fillStyle = grenade.color;
        ctx.fill();
        ctx.closePath();
    });
}

// 绘制地雷
function drawMines() {
    mines.forEach(mine => {
        // 绘制爆炸效果 (如果正在爆炸) - 橙色渐变圆形
        if (mine.isExploding) {
            const gradient = ctx.createRadialGradient(mine.x + mine.width / 2, mine.y + mine.height / 2, 0, mine.x + mine.width / 2, mine.y + mine.height / 2, MINE_EXPLOSION_RANGE);
            gradient.addColorStop(0, 'rgba(255, 165, 0, 1)'); // 橙色，完全不透明
            gradient.addColorStop(1, 'rgba(255, 165, 0, 0)'); // 橙色，完全透明
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(mine.x + mine.width / 2, mine.y + mine.height / 2, MINE_EXPLOSION_RANGE, 0, Math.PI * 2);
            ctx.fill();


        } else {
            // 根据地雷所有者设置颜色
            let mineColor, borderColor, dotColor;
            if (mine.owner === player) {
                // 玩家一的地雷 - 紫色，高可见度
                mineColor = 'rgba(128, 0, 128, 0.9)'; // 紫色，几乎不透明
                borderColor = 'rgba(75, 0, 130, 1.0)'; // 深紫色边框，完全不透明
                dotColor = 'rgba(255, 0, 255, 1.0)'; // 亮紫色点，完全不透明
            } else {
                // 玩家二的地雷 - 棕色，高可见度
                mineColor = 'rgba(139, 69, 19, 0.9)'; // 棕色，几乎不透明
                borderColor = 'rgba(101, 67, 33, 1.0)'; // 棕色边框，完全不透明
                dotColor = 'rgba(205, 133, 63, 1.0)'; // 亮棕色点，完全不透明
            }
            
            // 绘制地雷 - 更隐蔽的显示
            ctx.fillStyle = mineColor;
            ctx.fillRect(mine.x + 5, mine.y + 5, mine.width - 10, mine.height - 10); // 更小的尺寸
            
            // 绘制微弱的边框
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(mine.x + 5, mine.y + 5, mine.width - 10, mine.height - 10);
            
            // 绘制小点作为地雷标识
            ctx.fillStyle = dotColor;
            ctx.beginPath();
            ctx.arc(mine.x + mine.width/2, mine.y + mine.height/2, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // 如果地雷已被触发，显示倒计时
            if (mine.hasExploded) {
                const remainingTime = Math.max(0, Math.ceil((mine.explodeTime - Date.now()) / 1000));
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(remainingTime.toString(), mine.x + mine.width/2, mine.y - 5);
            }
        }
    });
}

// 显示冷却提示
function showCooldownMessage(skillName, remainingTime) {
    // 仅在屏幕左上角显示冷却提示，不覆盖整个屏幕
    ctx.fillStyle = 'white';
    ctx.font = '16px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(`${skillName}冷却中 (${remainingTime}秒)`, 10, 100);
}

// 启动决赛圈
function startFinalCircle() {
    finalCircleActive = true;
    // 初始决赛圈覆盖整个画布，留出一些边距
    finalCircleRadius = Math.min(canvas.width, canvas.height) * 0.8;
    finalCircleCenterX = canvas.width / 2;
    finalCircleCenterY = canvas.height / 2;
    finalCircleStartTime = Date.now();
    lastCircleDamageTime = Date.now();
    
    // 显示决赛圈开始提示
    console.log("决赛圈开始！初始半径:", finalCircleRadius);
}

// 更新决赛圈
function updateFinalCircle() {
    const currentTime = Date.now();
    const elapsedTime = currentTime - finalCircleStartTime;
    
    // 缩小决赛圈
    if (finalCircleRadius > FINAL_CIRCLE_MIN_RADIUS) {
        finalCircleRadius -= FINAL_CIRCLE_SHRINK_SPEED;
        if (finalCircleRadius < FINAL_CIRCLE_MIN_RADIUS) {
            finalCircleRadius = FINAL_CIRCLE_MIN_RADIUS;
        }
    }
    
    // 检查玩家是否在决赛圈外并造成伤害
    if (currentTime - lastCircleDamageTime >= FINAL_CIRCLE_DAMAGE_INTERVAL) {
        checkPlayerInCircle(player);
        if (player2) {
            checkPlayerInCircle(player2);
        }
        lastCircleDamageTime = currentTime;
    }
}

// 检查玩家是否在决赛圈内
function checkPlayerInCircle(p) {
    const playerCenterX = p.x + p.width / 2;
    const playerCenterY = p.y + p.height / 2;
    const distanceFromCenter = Math.sqrt(
        Math.pow(playerCenterX - finalCircleCenterX, 2) + 
        Math.pow(playerCenterY - finalCircleCenterY, 2)
    );
    
    // 如果玩家在决赛圈外，造成伤害
    if (distanceFromCenter > finalCircleRadius) {
        p.health -= FINAL_CIRCLE_DAMAGE;
        if (p.health <= 0) {
            p.health = 0;
            gameRunning = false; // 立即停止游戏
            // 根据游戏模式判断获胜者
            if (currentGameMode === 'single') {
                gameWinner = "你被干掉了！";
                console.log("玩家在决赛圈外死亡！");
            } else {
                // 双人模式
                if (p === player) {
                    gameWinner = "玩家2";
                    console.log("玩家1在决赛圈外死亡，玩家2获胜！");
                } else {
                    gameWinner = "玩家1";
                    console.log("玩家2在决赛圈外死亡，玩家1获胜！");
                }
            }
        }
    }
}

// 检查玩家PVP碰撞
function checkPlayerPVP() {
    if (!player2 || player.health <= 0 || player2.health <= 0) return;
    
    // 检查碰撞
    if (checkCollision(player, player2)) {
        if (!finalBattleStarted) {
            finalBattleStarted = true;
            console.log("进入决战阶段！");
        }
        
        // 双方扣血
        player.health -= PVP_DAMAGE;
        player2.health -= PVP_DAMAGE;
        
        // 检查是否有玩家死亡（PVP只在双人模式下发生）
        if (player.health <= 0 && player2.health <= 0) {
            gameRunning = false;
            gameWinner = "平局";
            console.log("双方在PVP中同时死亡，平局！");
        } else if (player.health <= 0) {
            gameRunning = false;
            gameWinner = "玩家2";
            console.log("玩家1在PVP中死亡，玩家2获胜！");
        } else if (player2.health <= 0) {
            gameRunning = false;
            gameWinner = "玩家1";
            console.log("玩家2在PVP中死亡，玩家1获胜！");
        }
    }
}

// 绘制决赛圈
function drawFinalCircle() {
    // 绘制决赛圈边界
    ctx.save();
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
    ctx.lineWidth = 5;
    ctx.setLineDash([10, 5]);
    ctx.beginPath();
    ctx.arc(finalCircleCenterX, finalCircleCenterY, finalCircleRadius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // 绘制决赛圈外的危险区域
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = 'red';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // 清除决赛圈内的区域
    ctx.globalCompositeOperation = 'destination-out';
    ctx.beginPath();
    ctx.arc(finalCircleCenterX, finalCircleCenterY, finalCircleRadius, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
    
    // 显示决赛圈信息
    ctx.fillStyle = 'white';
    ctx.font = 'bold 20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('决赛圈', canvas.width / 2, 50);
    
    // 显示决赛圈半径信息
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.font = '16px Arial';
    ctx.fillText(`安全区半径: ${Math.round(finalCircleRadius)}`, canvas.width / 2, 75);
    
    // 计算缩小进度
    const initialRadius = Math.min(canvas.width, canvas.height) * 0.8;
    const progress = ((initialRadius - finalCircleRadius) / (initialRadius - FINAL_CIRCLE_MIN_RADIUS) * 100);
    if (progress < 100) {
        ctx.fillText(`缩圈进度: ${Math.round(progress)}%`, canvas.width / 2, 95);
    }
    
    if (finalBattleStarted) {
        ctx.fillStyle = 'yellow';
        ctx.font = 'bold 24px Arial';
        ctx.fillText('决战阶段！', canvas.width / 2, 125);
    }
}

// 绘制获胜信息
function drawVictoryMessage() {
    ctx.save();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = 'gold';
    ctx.font = 'bold 48px Arial';
    ctx.textAlign = 'center';
    
    // 根据游戏模式和gameWinner内容显示不同信息
    if (currentGameMode === 'single') {
        // 单人模式：直接显示gameWinner的内容（如"你存活下来了！"或"你被干掉了！"）
        ctx.fillText(gameWinner, canvas.width / 2, canvas.height / 2);
    } else {
        // 双人模式：显示传统的胜利信息
        if (gameWinner === "平局") {
            ctx.fillText(gameWinner, canvas.width / 2, canvas.height / 2);
        } else {
            ctx.fillText(`${gameWinner}胜利！`, canvas.width / 2, canvas.height / 2);
        }
    }
    
    ctx.fillStyle = 'white';
    ctx.font = '24px Arial';
    ctx.fillText('按ESC键返回大厅', canvas.width / 2, canvas.height / 2 + 60);
    ctx.restore();
}



// 返回大厅
function returnToLobby() {
    // 停止游戏音乐
    const gameMusic = document.getElementById('gameMusic');
    if (gameMusic) {
        gameMusic.pause();
        gameMusic.currentTime = 0;
    }
    
    // 播放大厅音乐
    const bgMusic = document.getElementById('backgroundMusic');
    if (bgMusic) {
        bgMusic.play().catch(e => console.log("大厅音乐播放失败: ", e));
    }
    
    // 重置游戏状态
    gameRunning = false;
    gameWinner = null;
    currentGameMode = 'single';
    
    // 清空游戏元素
    enemies = [];
    bullets = [];
    purpleEnemyBullets = [];
    explosions = [];
    grenades = [];
    mines = [];
    boss = null;
    bossSpawned = false;
    
    // 重置决赛圈相关变量
    finalCircleActive = false;
    finalCircleRadius = 0;
    finalCircleCenterX = 0;
    finalCircleCenterY = 0;
    finalCircleStartTime = 0;
    finalBattleStarted = false;
    lastCircleDamageTime = 0;
    
    // 重置玩家
    player2 = null;
    
    // 恢复大厅背景
    document.body.style.backgroundColor = '';
    document.body.style.background = "linear-gradient(135deg, #667eea 0%, #764ba2 100%)";
    
    // 显示欢迎界面
    document.getElementById('welcomeScreen').style.display = 'flex';
    document.getElementById('gameCanvas').style.filter = 'blur(5px)';
    
    showSuggestionButton(); // 显示建议按钮
    
    console.log("返回大厅！");
}

// 建议功能相关代码
let suggestionStorage = [];

// 开发者模式相关变量
let isDeveloperMode = false;
let developerWebhookUrl = null;
let suggestionPollingInterval = null;
let lastCheckedTimestamp = Date.now();

// 初始化建议功能
function initSuggestionFeature() {
    const suggestionButton = document.getElementById('suggestionButton');
    const suggestionModal = document.getElementById('suggestionModal');
    const suggestionTextarea = document.getElementById('suggestionTextarea');
    const submitSuggestionBtn = document.getElementById('submitSuggestionBtn');
    const cancelSuggestionBtn = document.getElementById('cancelSuggestionBtn');
    const suggestionNotification = document.getElementById('suggestionNotification');
    
    // 点击建议按钮打开弹窗
    suggestionButton.addEventListener('click', function() {
        suggestionModal.style.display = 'block';
        suggestionTextarea.value = '';
        suggestionTextarea.focus();
    });
    
    // 取消按钮
    cancelSuggestionBtn.addEventListener('click', function() {
        suggestionModal.style.display = 'none';
    });
    
    // 点击弹窗外部关闭
    suggestionModal.addEventListener('click', function(e) {
        if (e.target === suggestionModal) {
            suggestionModal.style.display = 'none';
        }
    });
    
    // 提交建议
    submitSuggestionBtn.addEventListener('click', function() {
        const suggestionText = suggestionTextarea.value.trim();
        if (suggestionText === '') {
            console.log('请输入建议内容！');
            return;
        }
        
        // 存储建议
        const suggestion = {
            id: Date.now(),
            content: suggestionText,
            timestamp: new Date().toLocaleString(),
            userId: currentUser ? currentUser.id : 'anonymous',
            userName: currentUser ? currentUser.name : '匿名用户'
        };
        suggestionStorage.push(suggestion);
        
        // 演示模式：模拟跨设备建议收集 + 真实发送
        if (window.demoMode) {
            // 添加当前建议到演示列表
            const currentDevice = navigator.userAgent.includes('Mobile') ? 'Mobile Device' : 'Desktop PC';
            const newSuggestion = {
                device: currentDevice,
                suggestion: suggestionText,
                time: new Date().toLocaleString()
            };
            window.demoSuggestions.push(newSuggestion);
            
            // 显示跨设备收集效果
            console.log('\n🎉 建议已添加到跨设备收集系统！');
            console.log('\n📊 所有设备的建议汇总:');
            window.demoSuggestions.forEach((item, index) => {
                const isNew = index === window.demoSuggestions.length - 1;
                const prefix = isNew ? '🆕' : '  ';
                console.log(`${prefix} ${index + 1}. [${item.device}] ${item.suggestion} (${item.time})`);
            });
            console.log('\n✨ 这就是跨设备建议收集的效果！不同设备的建议都汇总在一起。');
            
            // 同时发送到真实的webhook（如果配置了的话）
            console.log('\n🌐 同时发送到真实服务器...');
            sendToWebhook(suggestionText);
        } else {
            // 真实模式：实际发送建议
            
            // 方法1: 发送到 Google Analytics (需要配置真实的测量ID)
            if (typeof gtag !== 'undefined') {
                gtag('event', 'user_suggestion', {
                    'event_category': 'User Feedback',
                    'event_label': 'Game Suggestion',
                    'custom_parameter_1': suggestionText,
                    'custom_parameter_2': new Date().toISOString(),
                    'value': 1
                });
            }
            
            // 方法1: 发送到免费的在线收集服务
            sendToWebhook(suggestionText);
            
            // 方法2: 生成可复制的建议数据
            generateCopyableData(suggestionText);
        }
        
        // 立即将建议存储到管理员邮箱
        addMessageToAdminMailbox(`收到新建议: ${suggestion.content}`, currentUser ? currentUser.name : '匿名用户');
        
        // 显示通知给用户
        showSuggestionNotification(suggestion.content);
        
        // 关闭弹窗
        suggestionModal.style.display = 'none';
        
        // 显示成功提示（仅在开发者控制台显示）
        console.log('感谢您的建议！已成功提交并保存到邮箱。');
        
        // 在控制台输出建议确认
        console.log('您的建议已记录:', suggestion);
        console.log('建议已发送到 Google Analytics 并保存到管理员邮箱');
    });
    
    // ESC键关闭弹窗
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && suggestionModal.style.display === 'block') {
            suggestionModal.style.display = 'none';
        }
    });
}

// 旧的建议通知函数已被新的邮箱功能替代

// 切换建议文本显示
function toggleSuggestionText() {
    const preview = document.getElementById('suggestionPreview');
    const full = document.getElementById('suggestionFull');
    const btn = document.getElementById('showFullBtn');
    
    if (preview.style.display === 'none') {
        preview.style.display = 'inline';
        full.style.display = 'none';
        btn.textContent = '显示全文';
    } else {
        preview.style.display = 'none';
        full.style.display = 'inline';
        btn.textContent = '收起';
    }
}

// 隐藏建议通知
function hideSuggestionNotification(shouldStoreToMailbox = false, message = '', userName = '') {
    const notification = document.getElementById('suggestionNotification');
    notification.className = '';
    
    // 移除重复添加消息的逻辑，因为消息已经在提交建议时添加过了
    // 避免邮箱中出现重复消息
}

// 在游戏开始时隐藏建议按钮
function hideSuggestionButton() {
    document.getElementById('suggestionButton').style.display = 'none';
}

// 显示建议按钮（现在一直显示）
function showSuggestionButton() {
    document.getElementById('suggestionButton').style.display = 'flex';
}

// 设置 Google Analytics 测量 ID 的辅助函数
function setupGoogleAnalytics(measurementId) {
    if (!measurementId) {
        console.warn('请提供有效的 Google Analytics 测量 ID');
        return;
    }
    
    // 更新 gtag 配置
    if (typeof gtag !== 'undefined') {
        gtag('config', measurementId);
        console.log('Google Analytics 已配置，测量 ID:', measurementId);
    } else {
        console.error('Google Analytics 未正确加载');
    }
}

// 检查 GA 设置状态
function checkGASetup() {
    const scripts = document.querySelectorAll('script[src*="googletagmanager"]');
    const hasGAScript = scripts.length > 0;
    const currentSrc = hasGAScript ? scripts[0].src : '';
    
    if (currentSrc.includes('GA_MEASUREMENT_ID')) {
        console.warn('⚠️ Google Analytics 设置提醒：');
        console.warn('1. 请访问 https://analytics.google.com/ 创建 GA4 属性');
        console.warn('2. 获取您的测量 ID（格式：G-XXXXXXXXXX）');
        console.warn('3. 在代码中将 "GA_MEASUREMENT_ID" 替换为您的实际测量 ID');
        console.warn('4. 或者调用 setupGoogleAnalytics("您的测量ID") 来动态设置');
        return false;
    }
    
    console.log('✅ Google Analytics 配置检查通过');
    return true;
}

// 页面加载完成后初始化建议功能
document.addEventListener('DOMContentLoaded', function() {
    initSuggestionFeature();
    
    // 显示邮箱和建议按钮（除了游戏进行中）
    showMailboxButton();
    showSuggestionButton();
    
    // 自动启用演示模式
    setTimeout(() => {
        enableDemoMode();
        console.log('\n🎮 游戏建议收集系统已启动');
        console.log('\n💡 演示模式已自动启用，现在提交建议即可看到跨设备通知效果！');
        
        // 检查跨设备通信配置
        if (!window.webhookUrl) {
            console.log('\n🌐 跨设备通信配置');
            console.log('📋 当前状态: 仅本地演示模式');
            console.log('🚀 启用真实跨设备通信的步骤:');
            console.log('   1. 访问: https://webhook.site/');
            console.log('   2. 复制显示的URL');
            console.log('   3. 运行: setupWebhook("您的URL")');
            console.log('💡 配置后，不同设备的建议将真正汇聚到您指定的地址！');
        } else {
            console.log('\n✅ 跨设备通信已启用: ' + window.webhookUrl);
        }
        
        // 验证状态
        setTimeout(() => {
            console.log('🔍 最终状态检查: isDeveloperMode =', isDeveloperMode);
            console.log('🔍 最终状态检查: window.demoMode =', window.demoMode);
        }, 500);
    }, 1000);
});

// 方法1: 发送到免费的在线收集服务
function sendToWebhook(suggestionText, customWebhookUrl = null) {
    // 使用自定义URL或默认配置的URL
    const webhookUrl = customWebhookUrl || window.webhookUrl;
    
    // 检查是否配置了 webhook URL
    if (!webhookUrl) {
        console.log('ℹ️ Webhook 未配置，跳过在线发送');
        console.log('💡 配置方法: setupWebhook("您的URL")');
        return;
    }
    
    // 生成或获取持久的设备ID
    if (!window.currentDeviceId) {
        window.currentDeviceId = 'device_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        console.log('🔧 生成设备ID:', window.currentDeviceId);
    }
    
    const data = {
        suggestion: suggestionText,
        timestamp: new Date().toISOString(),
        game: '对战游戏',
        userAgent: navigator.userAgent,
        url: window.location.href,
        deviceId: window.currentDeviceId,
        userId: currentUser ? currentUser.id : 'anonymous',
        userName: currentUser ? currentUser.name : '匿名用户',
        // 所有建议都发送给管理员账号00000000
        targetUserId: '00000000',
        originalUserId: currentUser ? currentUser.id : 'anonymous',
        originalUserName: currentUser ? currentUser.name : '匿名用户'
    };
    
    // 发送到配置的 webhook URL
    fetch(webhookUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(data)
    })
    .then(response => {
        if (response.ok) {
            console.log('✅ 建议已发送到 Webhook:', webhookUrl);
            if (customWebhookUrl) {
                console.log('📡 发送目标: 开发者监听地址');
            }
        } else {
            console.log('⚠️ Webhook 响应异常，但数据已发送');
        }
    })
    .catch(error => {
        console.log('❌ Webhook 发送失败:', error.message);
        console.log('💡 请检查 URL 是否正确或网络连接');
    });
}

// 方法2: 生成可复制的建议数据
function generateCopyableData(suggestionText) {
    const data = {
        建议内容: suggestionText,
        提交时间: new Date().toLocaleString(),
        游戏名称: '对战游戏',
        用户ID: 'user_' + Date.now()
    };
    
    const formattedData = JSON.stringify(data, null, 2);
    
    // 尝试复制到剪贴板
    if (navigator.clipboard) {
        navigator.clipboard.writeText(formattedData).then(() => {
            console.log('📋 建议数据已复制到剪贴板');
        }).catch(() => {
            console.log('📋 建议数据:', formattedData);
        });
    } else {
        console.log('📋 建议数据:', formattedData);
    }
}



// 方法3: 通过邮件发送 (备用方案)
function sendByEmail(suggestionText) {
    // 使用 EmailJS 服务 (需要配置)
    if (typeof emailjs !== 'undefined') {
        emailjs.send('YOUR_SERVICE_ID', 'YOUR_TEMPLATE_ID', {
            suggestion: suggestionText,
            timestamp: new Date().toLocaleString(),
            game: '对战游戏'
        })
        .then(function(response) {
            console.log('✅ 建议已通过邮件发送');
        }, function(error) {
            console.warn('⚠️ 邮件发送失败:', error);
        });
    } else {
        // 备用方案：生成 mailto 链接
        const subject = encodeURIComponent('游戏建议反馈');
        const body = encodeURIComponent(`建议内容：${suggestionText}\n\n时间：${new Date().toLocaleString()}\n游戏：对战游戏`);
        const mailtoLink = `mailto:your-email@example.com?subject=${subject}&body=${body}`;
        
        console.log('📧 邮件链接已生成:', mailtoLink);
        console.log('💡 提示：您可以点击此链接发送邮件，或配置 EmailJS 实现自动发送');
    }
}

// 方法4: 发送到 Google Sheets (额外选项)
function sendToGoogleSheets(suggestionText) {
    // 使用 Google Apps Script Web App
    const scriptUrl = 'YOUR_GOOGLE_SCRIPT_URL';
    
    fetch(scriptUrl, {
        method: 'POST',
        mode: 'no-cors',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            suggestion: suggestionText,
            timestamp: new Date().toISOString(),
            game: '对战游戏'
        })
    })
    .then(() => {
        console.log('✅ 建议已发送到 Google Sheets');
    })
    .catch(error => {
        console.warn('⚠️ Google Sheets 发送出错:', error.message);
    });
}

// 建议收集问题解决助手
function setupSuggestionCollection() {
    console.log('🔍 建议收集问题诊断与解决');
    
    if (window.webhookUrl) {
        console.log('\n✅ 系统状态: 跨设备收集已启用');
        console.log('🌐 Webhook URL:', window.webhookUrl);
        console.log('📊 您的建议数据会发送到上述网址，可以在那里查看所有设备的建议');
    } else {
        console.log('\n❌ 问题: 建议只保存在本地，无法跨设备收集');
        console.log('\n🎯 解决方案: 启用跨设备收集 (2分钟搞定)');
        console.log('\n📋 详细步骤:');
        console.log('   1. 打开新标签页，访问: https://webhook.site/');
        console.log('   2. 页面会显示一个唯一的URL (类似: https://webhook.site/12345...)');
        console.log('   3. 复制这个URL');
        console.log('   4. 回到这里，运行: setupWebhook("粘贴您复制的URL")');
        console.log('   5. 完成！现在您在所有设备上的建议都会汇总到那个网页');
        console.log('\n💡 提示: webhook.site 是免费服务，无需注册');
    }
    
    console.log('\n=== 当前收集方式 ===');
    console.log('📥 本地下载: 已启用 (您的每次建议都会下载JSON文件)');
    console.log('📋 剪贴板: 已启用 (您的建议数据自动复制到剪贴板)');
    console.log('🌐 跨设备收集: ' + (window.webhookUrl ? '✅ 已启用' : '❌ 未启用'));
}

// 快速配置函数
function setupWebhook(url) {
    if (!url) {
        console.error('请提供 Webhook URL');
        console.log('💡 获取方法: 访问 https://webhook.site/ 并复制您的唯一URL');
        return;
    }
    
    // 简单验证URL格式
    if (!url.startsWith('http')) {
        console.error('❌ URL格式错误，请确保以 http:// 或 https:// 开头');
        return;
    }
    
    window.webhookUrl = url;
    console.log('\n🎉 跨设备收集已启用！');
    console.log('🌐 Webhook URL:', url);
    
    // 自动启用开发者模式来接收其他设备的通知
    enableDeveloperMode(url);
    
    console.log('\n📋 验证步骤:');
    console.log('   1. 在另一台设备上访问您的游戏页面');
    console.log('   2. 其他人点击建议按钮并提交建议');
    console.log('   3. 您的电脑会立即弹出蓝色通知！');
    console.log('   4. 也可以到 webhook.site 页面查看所有数据');
    console.log('\n💡 现在您可以接收来自所有设备的建议通知了！');
}

function setupFormspree(formId) {
    if (!formId) {
        console.error('请提供 Formspree 表单 ID');
        return;
    }
    
    window.formspreeEndpoint = `https://formspree.io/f/${formId}`;
    console.log('✅ Formspree 已配置:', window.formspreeEndpoint);
}

function setupEmailJS(serviceId, templateId) {
    if (!serviceId || !templateId) {
        console.error('请提供 EmailJS 服务ID和模板ID');
        return;
    }
    
    window.emailjsConfig = { serviceId, templateId };
    console.log('✅ EmailJS 已配置');
}

// 开发者模式功能
function enableDeveloperMode(webhookUrl) {
    if (!webhookUrl) {
        console.error('❌ 请提供有效的 Webhook URL');
        console.log('💡 获取方法: 访问 https://webhook.site/ 并复制您的唯一URL');
        return;
    }
    
    // 确保设备ID已生成
    if (!window.currentDeviceId) {
        window.currentDeviceId = 'device_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        console.log('🔧 生成设备ID:', window.currentDeviceId);
    }
    
    isDeveloperMode = true;
    developerWebhookUrl = webhookUrl;
    lastCheckedTimestamp = Date.now();
    
    console.log('🔧 开发者模式已启用');
    console.log('📡 监听地址:', webhookUrl);
    console.log('🆔 本设备ID:', window.currentDeviceId);
    console.log('🔄 开始实时监听其他设备的建议...');
    console.log('💡 注意: 来自本设备的建议将被自动过滤，只显示其他设备的建议');
    
    // 开始轮询检查新建议
    startSuggestionPolling();
    
    // 显示开发者模式状态
    showDeveloperModeStatus();
}

function startSuggestionPolling() {
    if (suggestionPollingInterval) {
        clearInterval(suggestionPollingInterval);
    }
    
    // 立即执行一次检查
    checkForNewSuggestions();
    
    suggestionPollingInterval = setInterval(() => {
        checkForNewSuggestions();
    }, 3000); // 每3秒检查一次
    
    console.log('🔄 建议轮询已启动，每3秒检查一次新建议');
}

// 已显示的建议ID集合，避免重复显示
let displayedSuggestionIds = new Set();

function checkForNewSuggestions() {
    if (!isDeveloperMode || !developerWebhookUrl) return;
    
    // 这里使用webhook.site的API来获取新的请求
    const webhookId = developerWebhookUrl.split('/').pop();
    const apiUrl = `https://webhook.site/token/${webhookId}/requests`;
    
    fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
            if (data && data.data) {
                // 过滤出新的建议（排除来自本设备的建议和已显示的建议）
                const newSuggestions = data.data.filter(request => {
                    const requestTime = new Date(request.created_at).getTime();
                    if (requestTime <= lastCheckedTimestamp || 
                        request.method !== 'POST' ||
                        !request.content) {
                        return false;
                    }
                    
                    try {
                        const suggestionData = JSON.parse(request.content);
                        
                        // 排除来自本设备的建议
                        if (suggestionData.deviceId === window.currentDeviceId) {
                            console.log('🔍 跳过本设备建议:', suggestionData.suggestion);
                            return false;
                        }
                        
                        // 生成唯一ID来避免重复显示
                        const suggestionId = `${request.uuid || request.created_at}_${suggestionData.suggestion.substring(0, 20)}`;
                        if (displayedSuggestionIds.has(suggestionId)) {
                            console.log('🔍 跳过已显示建议:', suggestionData.suggestion);
                            return false;
                        }
                        
                        // 标记为已显示
                        displayedSuggestionIds.add(suggestionId);
                        
                        return suggestionData.suggestion;
                    } catch (e) {
                        return false;
                    }
                });
                
                // 显示新建议
                newSuggestions.forEach(request => {
                    const suggestionData = JSON.parse(request.content);
                    showDeveloperNotification(suggestionData, request.created_at);
                });
                
                // 更新最后检查时间
                if (data.data.length > 0) {
                    lastCheckedTimestamp = Math.max(...data.data.map(r => new Date(r.created_at).getTime()));
                }
                
                // 清理过期的已显示建议ID（保留最近1小时的记录）
                const oneHourAgo = Date.now() - 3600000;
                const expiredIds = Array.from(displayedSuggestionIds).filter(id => {
                    const timestamp = id.split('_')[0];
                    return new Date(timestamp).getTime() < oneHourAgo;
                });
                expiredIds.forEach(id => displayedSuggestionIds.delete(id));
            }
        })
        .catch(error => {
            console.log('🔍 轮询检查中...', new Date().toLocaleTimeString());
        });
}

function showDeveloperNotification(suggestionData, timestamp) {
    console.log('💻 显示开发者通知: ' + suggestionData.suggestion);
    console.log('🔍 调试: showDeveloperNotification 函数被调用');
    
    const notification = document.getElementById('developerNotification');
    console.log('🔍 调试: developerNotification 元素:', notification);
    
    if (!notification) {
        console.error('❌ 错误: 找不到 developerNotification 元素!');
        return;
    }
    
    // 解析设备信息
    const userAgent = suggestionData.userAgent || '';
    let deviceInfo = '🖥️ 未知设备';
    if (userAgent.includes('Mobile') || userAgent.includes('Android') || userAgent.includes('iPhone')) {
        deviceInfo = '📱 移动设备';
    } else if (userAgent.includes('Windows') || userAgent.includes('Mac') || userAgent.includes('Linux')) {
        deviceInfo = '💻 桌面设备';
    }
    
    // 格式化时间
    const date = new Date(timestamp);
    const timeStr = date.toLocaleString();
    
    // 处理长文本
    const suggestion = suggestionData.suggestion || '';
    let notificationHTML;
    
    if (suggestion.length > 50) {
        const preview = suggestion.substring(0, 50) + '...';
        notificationHTML = `
            <div style="margin-bottom: 10px;">
                <strong>🔔 收到新建议</strong><br>
                <small>${deviceInfo} • ${timeStr}</small>
            </div>
            <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; margin: 10px 0;">
                <span id="devSuggestionPreview">${preview}</span>
                <span id="devSuggestionFull" style="display: none;">${suggestion}</span>
                <br><button onclick="toggleDevSuggestionText()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 4px 8px; border-radius: 3px; margin-top: 5px; cursor: pointer; font-size: 12px;">显示全文</button>
            </div>
            <button onclick="hideDeveloperNotification()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 15px; border-radius: 5px; margin-top: 10px; cursor: pointer;">知道了</button>
        `;
    } else {
        notificationHTML = `
            <div style="margin-bottom: 10px;">
                <strong>🔔 收到新建议</strong><br>
                <small>${deviceInfo} • ${timeStr}</small>
            </div>
            <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; margin: 10px 0;">
                ${suggestion}
            </div>
            <button onclick="hideDeveloperNotification()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 15px; border-radius: 5px; margin-top: 10px; cursor: pointer;">知道了</button>
        `;
    }
    
    notification.innerHTML = notificationHTML;
    notification.style.display = 'block';
    notification.style.animation = 'slideIn 0.5s ease-out';
    
    // 10秒后自动消失
    setTimeout(() => {
        if (notification.style.display === 'block') {
            hideDeveloperNotification();
        }
    }, 10000);
    
    console.log('✅ 开发者通知已显示');
    console.log('🔍 调试: notification.style.display =', notification.style.display);
    console.log('🔍 调试: notification.offsetHeight =', notification.offsetHeight);
    console.log('🔍 调试: notification.offsetWidth =', notification.offsetWidth);
    console.log('🔔 收到新建议:', suggestionData.suggestion);
    console.log('📊 设备信息:', deviceInfo);
    console.log('⏰ 提交时间:', timeStr);
}

// 隐藏开发者通知
function hideDeveloperNotification() {
    const notification = document.getElementById('developerNotification');
    notification.style.display = 'none';
}

// 切换开发者通知中的建议文本显示
function toggleDevSuggestionText() {
    const preview = document.getElementById('devSuggestionPreview');
    const full = document.getElementById('devSuggestionFull');
    const btn = event.target;
    
    if (preview.style.display === 'none') {
        preview.style.display = 'inline';
        full.style.display = 'none';
        btn.textContent = '显示全文';
    } else {
        preview.style.display = 'none';
        full.style.display = 'inline';
        btn.textContent = '收起';
    }
}

function showDeveloperModeStatus() {
    const statusDiv = document.createElement('div');
    statusDiv.id = 'developerModeStatus';
    statusDiv.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px;
        border-radius: 10px;
        font-size: 12px;
        z-index: 1002;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        max-width: 250px;
    `;
    
    statusDiv.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 8px;">🔧 开发者模式</div>
        <div>📡 正在监听用户建议...</div>
        <div style="font-size: 10px; opacity: 0.8; margin-top: 5px;">每3秒检查一次新建议</div>
        <button onclick="disableDeveloperMode()" style="
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            margin-top: 8px;
        ">关闭监听</button>
    `;
    
    // 移除旧的状态显示
    const oldStatus = document.getElementById('developerModeStatus');
    if (oldStatus) oldStatus.remove();
    
    document.body.appendChild(statusDiv);
}

function disableDeveloperMode() {
    isDeveloperMode = false;
    developerWebhookUrl = null;
    
    if (suggestionPollingInterval) {
        clearInterval(suggestionPollingInterval);
        suggestionPollingInterval = null;
    }
    
    const statusDiv = document.getElementById('developerModeStatus');
    if (statusDiv) statusDiv.remove();
    
    console.log('🔧 开发者模式已关闭');
}

// 启用演示模式（无需真实webhook）
function enableDemoMode() {
    isDeveloperMode = true;
    window.demoMode = true;
    window.demoSuggestions = window.demoSuggestions || [];
    console.log('🎮 演示模式已启用');
    console.log('🔍 调试: enableDemoMode 设置 isDeveloperMode =', isDeveloperMode);
    console.log('🔍 调试: enableDemoMode 设置 window.demoMode =', window.demoMode);
    console.log('💡 现在提交建议时，您将看到跨设备通知演示效果');
    console.log('📱 建议提交后会显示"发送成功"，然后开发者端会收到通知');
    
    // 显示演示模式状态
    const statusDiv = document.createElement('div');
    statusDiv.id = 'demoModeStatus';
    statusDiv.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(0, 150, 255, 0.9);
        color: white;
        padding: 10px 15px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    statusDiv.innerHTML = `
        🎮 演示模式已启用<br>
        <small>提交建议可体验跨设备通知</small>
    `;
    
    // 移除旧的状态显示
    const oldStatus = document.getElementById('demoModeStatus');
    if (oldStatus) oldStatus.remove();
    
    document.body.appendChild(statusDiv);
    
    // 3秒后自动隐藏状态提示（不影响演示模式功能）
    setTimeout(() => {
        if (statusDiv && statusDiv.parentNode) {
            statusDiv.remove();
        }
    }, 3000);
}

function disableDemoMode() {
    isDeveloperMode = false;
    window.demoMode = false;
    
    const statusDiv = document.getElementById('demoModeStatus');
    if (statusDiv) statusDiv.remove();
    
    console.log('🎮 演示模式已关闭');
}

// 导出全局函数供开发者使用
window.setupSuggestionCollection = setupSuggestionCollection;
window.setupWebhook = setupWebhook;
window.setupFormspree = setupFormspree;
window.enableDeveloperMode = enableDeveloperMode;
window.disableDeveloperMode = disableDeveloperMode;
window.enableDemoMode = enableDemoMode;
window.disableDemoMode = disableDemoMode;
window.setupEmailJS = setupEmailJS;
window.setupGA = setupGoogleAnalytics;
window.checkGA = checkGASetup;
window.sendToGoogleSheets = sendToGoogleSheets;

// 页面加载完成后初始化用户数据和登录系统
window.addEventListener('DOMContentLoaded', async function() {
    console.log('页面DOMContentLoaded事件触发');
    
    try {
        // 首先初始化用户数据
        console.log('准备调用initializeUserData');
        await initializeUserData();
        console.log('initializeUserData调用成功');
        
        // 然后初始化登录系统
        console.log('准备调用initLoginSystem');
        initLoginSystem();
        console.log('initLoginSystem调用成功');
    } catch (error) {
        console.error('初始化过程中发生错误:', error);
    }
});

// 通过用户ID查看建议的功能
function getSuggestionsByUserId(userId) {
    console.log('🔍 查找用户ID为 ' + userId + ' 的建议:');
    
    const userSuggestions = suggestionStorage.filter(suggestion => 
        suggestion.userId === userId
    );
    
    if (userSuggestions.length === 0) {
        console.log('❌ 未找到该用户的建议');
        return [];
    }
    
    console.log('✅ 找到 ' + userSuggestions.length + ' 条建议:');
    userSuggestions.forEach((suggestion, index) => {
        console.log(`${index + 1}. [${suggestion.timestamp}] ${suggestion.content}`);
    });
    
    return userSuggestions;
}

// 通过用户名查看建议的功能
function getSuggestionsByUserName(userName) {
    console.log('🔍 查找用户名为 "' + userName + '" 的建议:');
    
    const userSuggestions = suggestionStorage.filter(suggestion => 
        suggestion.userName === userName
    );
    
    if (userSuggestions.length === 0) {
        console.log('❌ 未找到该用户的建议');
        return [];
    }
    
    console.log('✅ 找到 ' + userSuggestions.length + ' 条建议:');
    userSuggestions.forEach((suggestion, index) => {
        console.log(`${index + 1}. [${suggestion.timestamp}] ${suggestion.content}`);
    });
    
    return userSuggestions;
}

// 查看所有建议并按用户分组
function getAllSuggestionsGroupedByUser() {
    console.log('📊 所有建议按用户分组:');
    
    if (suggestionStorage.length === 0) {
        console.log('❌ 暂无建议记录');
        return {};
    }
    
    const groupedSuggestions = {};
    
    suggestionStorage.forEach(suggestion => {
        const key = `${suggestion.userName} (ID: ${suggestion.userId})`;
        if (!groupedSuggestions[key]) {
            groupedSuggestions[key] = [];
        }
        groupedSuggestions[key].push(suggestion);
    });
    
    Object.keys(groupedSuggestions).forEach(userKey => {
        console.log(`\n👤 ${userKey}:`);
        groupedSuggestions[userKey].forEach((suggestion, index) => {
            console.log(`   ${index + 1}. [${suggestion.timestamp}] ${suggestion.content}`);
        });
    });
    
    return groupedSuggestions;
}

// 删除特定用户的建议
function deleteSuggestionsByUserId(userId) {
    console.log('🗑️ 删除用户ID为 ' + userId + ' 的所有建议...');
    
    const initialCount = suggestionStorage.length;
    suggestionStorage = suggestionStorage.filter(suggestion => 
        suggestion.userId !== userId
    );
    
    const deletedCount = initialCount - suggestionStorage.length;
    
    if (deletedCount > 0) {
        console.log('✅ 已删除 ' + deletedCount + ' 条建议');
    } else {
        console.log('❌ 未找到该用户的建议');
    }
    
    return deletedCount;
}

// 管理员查看所有建议功能（专为账号00000000设计）
function getAdminSuggestions() {
    console.log('👑 管理员建议汇总 (目标账号: 00000000):');
    
    if (suggestionStorage.length === 0) {
        console.log('❌ 暂无建议记录');
        return [];
    }
    
    console.log('\n📊 所有用户建议汇总:');
    suggestionStorage.forEach((suggestion, index) => {
        const userInfo = suggestion.userId === 'anonymous' ? 
            '匿名用户' : 
            `${suggestion.userName} (ID: ${suggestion.userId})`;
        console.log(`${index + 1}. [${suggestion.timestamp}] ${userInfo}: ${suggestion.content}`);
    });
    
    console.log('\n📈 统计信息:');
    const userStats = {};
    suggestionStorage.forEach(suggestion => {
        const key = suggestion.userId === 'anonymous' ? '匿名用户' : suggestion.userId;
        userStats[key] = (userStats[key] || 0) + 1;
    });
    
    Object.keys(userStats).forEach(userId => {
        const userName = userId === '匿名用户' ? '匿名用户' : 
            suggestionStorage.find(s => s.userId === userId)?.userName || '未知';
        console.log(`   ${userName} (${userId}): ${userStats[userId]} 条建议`);
    });
    
    return suggestionStorage;
}

// 检查当前用户是否为管理员
function checkAdminAccess() {
    if (currentUser && currentUser.id === '00000000') {
        console.log('✅ 管理员权限确认！您可以使用 getAdminSuggestions() 查看所有建议');
        return true;
    } else {
        console.log('❌ 非管理员账号，请使用账号00000000登录后查看');
        return false;
    }
}

// 使用说明
function showSuggestionManagementHelp() {
    console.log('\n📋 建议管理功能使用说明:');
    console.log('\n🔍 查看功能:');
    console.log('   getSuggestionsByUserId("用户ID")     - 查看指定用户ID的建议');
    console.log('   getSuggestionsByUserName("用户名")   - 查看指定用户名的建议');
    console.log('   getAllSuggestionsGroupedByUser()    - 查看所有建议并按用户分组');
    console.log('\n👑 管理员功能 (仅限账号00000000):');
    console.log('   getAdminSuggestions()               - 查看所有用户发送的建议汇总');
    console.log('   checkAdminAccess()                  - 检查管理员权限');
    console.log('\n🗑️ 管理功能:');
    console.log('   deleteSuggestionsByUserId("用户ID") - 删除指定用户的所有建议');
    console.log('\n💡 示例:');
    console.log('   getSuggestionsByUserId("00000001")  - 查看ID为00000001的用户建议');
    console.log('   getSuggestionsByUserName("张三")     - 查看用户名为张三的建议');
    console.log('   getAdminSuggestions()               - 管理员查看所有建议');
    console.log('\n📊 当前建议总数:', suggestionStorage.length);
}

// 快速登录管理员函数
function loginAsAdmin() {
    const adminUser = users.find(user => user.id === '00000000');
    if (adminUser) {
        currentUser = adminUser;
        console.log('✅ 已快速登录管理员账号:', adminUser.name);
        
        // 隐藏登录界面，显示欢迎界面
        document.getElementById('loginScreen').style.display = 'none';
        document.getElementById('welcomeScreen').style.display = 'block';
        
        // 初始化邮箱
        initializeMailbox();
        updateUnreadCount();
        // 只有在有未读消息时才显示邮箱按钮
        if (mailboxMessages.filter(msg => !msg.read).length > 0) {
            showMailboxButton();
        }
        
        console.log('📧 邮箱功能已激活，请查看右上角邮箱按钮');
    } else {
        console.log('❌ 管理员账号不存在');
    }
}

// 邮箱功能相关变量和函数
let mailboxMessages = [];
let mailboxAutoHideTimer = null;
let isGameStarted = false;
let gameRunning = false;

// 初始化邮箱消息（根据用户类型）
function initializeMailbox() {
    if (currentUser && currentUser.id === '00000000') {
        // 管理员加载管理员邮箱
        mailboxMessages = JSON.parse(localStorage.getItem('adminMailboxMessages') || '[]');
    } else {
        // 普通用户不需要邮箱
        mailboxMessages = [];
    }
}

// 更新未读消息计数
function updateUnreadCount() {
    const unreadCount = mailboxMessages.filter(msg => !msg.read).length;
    const badge = document.getElementById('unreadCount');
    if (unreadCount > 0) {
        badge.textContent = unreadCount;
        badge.classList.remove('hidden');
    } else {
        badge.classList.add('hidden');
    }
}

// 添加消息到邮箱
function addMessageToMailbox(content, type = 'suggestion') {
    const message = {
        id: Date.now() + Math.random(),
        content: content,
        type: type,
        timestamp: new Date().toISOString(),
        read: false
    };
    
    mailboxMessages.unshift(message); // 最新消息在前
    localStorage.setItem('mailboxMessages', JSON.stringify(mailboxMessages));
    updateUnreadCount();
    showMailboxButton();
}

// 添加消息到管理员邮箱
function addMessageToAdminMailbox(content, fromUser) {
    // 管理员邮箱消息存储在专门的key中
    let adminMessages = JSON.parse(localStorage.getItem('adminMailboxMessages') || '[]');
    
    const message = {
        id: Date.now() + Math.random(),
        content: content,
        fromUser: fromUser,
        type: 'suggestion',
        timestamp: new Date().toISOString(),
        read: false
    };
    
    adminMessages.unshift(message); // 最新消息在前
    localStorage.setItem('adminMailboxMessages', JSON.stringify(adminMessages));
    
    // 如果当前用户是管理员，更新邮箱显示
    if (currentUser && currentUser.id === '00000000') {
        mailboxMessages = adminMessages;
        updateUnreadCount();
        showMailboxButton();
    }
}

// 显示邮箱按钮（只有管理员可见）
function showMailboxButton() {
    const mailboxButton = document.getElementById('mailboxButton');
    
    // 只有管理员才能看到邮箱按钮
    if (currentUser && currentUser.id === '00000000') {
        mailboxButton.style.display = 'flex';
        resetAutoHideTimer();
    } else {
        mailboxButton.style.display = 'none';
    }
}

// 隐藏邮箱按钮
function hideMailboxButton() {
    const mailboxButton = document.getElementById('mailboxButton');
    mailboxButton.style.display = 'none';
    clearTimeout(mailboxAutoHideTimer);
}

// 重置自动隐藏计时器（现在不再自动隐藏按钮）
function resetAutoHideTimer() {
    clearTimeout(mailboxAutoHideTimer);
    // 邮箱按钮现在一直显示，不再自动隐藏
}

// 显示邮箱弹窗
function showMailboxModal() {
    const modal = document.getElementById('mailboxModal');
    modal.style.display = 'flex';
    renderMailboxMessages();
    resetAutoHideTimer();
}

// 隐藏邮箱弹窗
function hideMailboxModal() {
    const modal = document.getElementById('mailboxModal');
    modal.style.display = 'none';
}

// 渲染邮箱消息
function renderMailboxMessages() {
    const messagesContainer = document.getElementById('mailboxMessages');
    
    if (mailboxMessages.length === 0) {
        messagesContainer.innerHTML = '<div class="empty-state"><p>这里是空空哒</p></div>';
        return;
    }
    
    const messagesHtml = mailboxMessages.map(message => {
        const date = new Date(message.timestamp);
        const timeStr = date.toLocaleString('zh-CN');
        const fromUserInfo = message.fromUser ? `来自: ${message.fromUser}` : '';
        
        return `
            <div class="message-item" data-message-id="${message.id}">
                <div class="message-header">
                    <span class="message-from">${fromUserInfo}</span>
                    <span class="message-time">${timeStr}</span>
                </div>
                <div class="message-content">${message.content}</div>
                <button class="message-dismiss" onclick="dismissMessage('${message.id}')">知道了</button>
            </div>
        `;
    }).join('');
    
    messagesContainer.innerHTML = messagesHtml;
}

// 消除单个消息
function dismissMessage(messageId) {
    mailboxMessages = mailboxMessages.filter(msg => msg.id != messageId);
    
    // 如果是管理员，更新管理员邮箱存储
    if (currentUser && currentUser.id === '00000000') {
        localStorage.setItem('adminMailboxMessages', JSON.stringify(mailboxMessages));
    } else {
        localStorage.setItem('mailboxMessages', JSON.stringify(mailboxMessages));
    }
    
    updateUnreadCount();
    renderMailboxMessages();
    
    // 如果没有消息了，显示空状态
    if (mailboxMessages.length === 0) {
        setTimeout(() => {
            hideMailboxModal();
        }, 500);
    }
}

// 修改原有的建议发送成功通知函数
function showSuggestionNotification(message) {
    // 显示用户建议发送成功通知
    console.log('📤 显示用户通知: ' + message);
    
    const notification = document.getElementById('suggestionNotification');
    
    notification.innerHTML = `
        <strong>✅ 建议发送成功！</strong><br>
        <small>⏰ ${new Date().toLocaleString()}</small><br>
        <small>📧 您的建议已发送给管理员</small><br>
        <button onclick="hideSuggestionNotification(true, '${message.replace(/'/g, "\\'").replace(/"/g, '\\"')}', '${currentUser ? currentUser.name.replace(/'/g, "\\'").replace(/"/g, '\\"') : '匿名用户'}')" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 15px; border-radius: 5px; margin-top: 10px; cursor: pointer;">知道了</button>
    `;
    
    notification.className = 'show';
    
    // 10秒后自动消失
    setTimeout(() => {
        if (notification.classList.contains('show')) {
            hideSuggestionNotification();
        }
    }, 10000);
    
    // 如果启用了开发者模式，1秒后显示开发者收到的通知
    if (isDeveloperMode) {
        console.log('⏰ 开发者模式已启用，1秒后将显示开发者通知');
        setTimeout(() => {
            console.log('📥 触发开发者通知');
            showDeveloperNotification({
                suggestion: message,
                userAgent: navigator.userAgent
            }, new Date().toISOString());
        }, 1000);
    } else {
        console.log('⚠️ 开发者模式未启用，不会显示开发者通知');
        console.log('🔍 当前 isDeveloperMode 值:', isDeveloperMode);
    }
}

// 游戏开始时隐藏邮箱、创建房间和广场按钮
function onGameStart() {
    isGameStarted = true;
    gameRunning = true;
    // 游戏开始时隐藏邮箱模态框
    hideMailboxModal();
    // 隐藏邮箱、创建房间和广场按钮
    hideMailboxButton();
    const createRoomButton = document.getElementById('createRoomButton');
    const squareButton = document.getElementById('squareButton');
    if (createRoomButton) {
        createRoomButton.style.display = 'none';
    }
    if (squareButton) {
        squareButton.style.display = 'none';
    }
}

// 游戏结束时重新显示所有按钮
function onGameEnd() {
    isGameStarted = false;
    gameRunning = false;
    // 游戏结束后重新显示邮箱和建议按钮
    showMailboxButton();
    showSuggestionButton();
    // 重新显示创建房间和广场按钮
    const createRoomButton = document.getElementById('createRoomButton');
    const squareButton = document.getElementById('squareButton');
    if (createRoomButton) {
        createRoomButton.style.display = 'flex';
    }
    if (squareButton) {
        squareButton.style.display = 'flex';
    }
}

// 添加页面加载测试
console.log('JavaScript代码开始执行');
window.addEventListener('load', function() {
    console.log('页面完全加载完成');
    console.log('\n💡 提示: 输入 showSuggestionManagementHelp() 查看建议管理功能');
    console.log('\n📧 邮箱测试: 使用账号 00000000 密码 993966 登录查看管理员邮箱');
    console.log('\n🔧 快速登录管理员: 输入 loginAsAdmin() 快速登录管理员账号');
    
    // 初始化邮箱功能
    initializeMailbox();
    updateUnreadCount();
    
    // 设置全局函数
    window.loginAsAdmin = loginAsAdmin;
    window.showSuggestionManagementHelp = showSuggestionManagementHelp;
    
    // 邮箱按钮点击事件
    document.getElementById('mailboxButton').addEventListener('click', function() {
        showMailboxModal();
    });
    
    // 关闭邮箱弹窗事件
    document.getElementById('closeMailboxBtn').addEventListener('click', function() {
        hideMailboxModal();
    });
    
    // 房间管理系统
    let currentRoom = null;
    let roomCountdown = null;
    let isRoomOwner = false;
    
    // 创建房间按钮点击事件
    document.getElementById('createRoomButton').addEventListener('click', function() {
        showRoomNameModal();
    });
    
    // 显示房间名输入弹窗
    function showRoomNameModal() {
        document.getElementById('roomNameModal').style.display = 'block';
        document.getElementById('roomNameInput').focus();
    }
    
    // confirmRoomName函数已在script开头定义
    
    // 房间创建相关函数已在script开头定义
    
    // showWaitingRoom函数已移动到script开头
    
    // updateRoomInfo函数已移动到script开头
    
    // startRoomCountdown和startGameCountdown函数已移动到script开头
    
    // startGameCountdown函数已移动到script开头
    
    // 大乱斗游戏状态
    let battleRoyaleState = {
        players: [],
        alivePlayers: [],
        gameStarted: false,
        finalCircleActive: false,
        circleRadius: 400,
        circleCenter: { x: 400, y: 300 },
        circleSpeed: 0.5 // 比原来慢10倍
    };
    
    // 开始大乱斗游戏
    function startBattleRoyaleGame() {
        // 初始化游戏状态
        battleRoyaleState.gameStarted = true;
        
        // 只在第一次初始化时创建玩家数组，避免重复分配颜色
        if (battleRoyaleState.players.length === 0) {
            battleRoyaleState.players = currentRoom.players.map((name, index) => ({
                id: index,
                name: name,
                x: 0,
                y: 0,
                health: 100,
                alive: true,
                color: getPlayerColor(index)
            }));
        } else {
            // 如果玩家数组已存在，只重置位置和状态，保持颜色不变
            battleRoyaleState.players.forEach(player => {
                player.x = 0;
                player.y = 0;
                player.health = 100;
                player.alive = true;
            });
        }
        
        battleRoyaleState.alivePlayers = [...battleRoyaleState.players];
        
        // 随机分散出生玩家
        spawnPlayersRandomly();
        
        // 显示游戏界面
        showGameInterface();
        
        // 开始游戏循环
        startGameLoop();
        
        alert('大乱斗游戏开始！使用技能消灭其他玩家！');
    }
    
    // 获取玩家颜色
    function getPlayerColor(index) {
        // 固定颜色，不再变化
        const colors = ['blue', 'red', 'green', 'orange'];
        return colors[index % colors.length];
    }
    
    // 随机分散出生玩家
    function spawnPlayersRandomly() {
        const spawnPositions = [];
        const minDistance = 100; // 最小距离防止重叠
        
        battleRoyaleState.players.forEach(player => {
            let validPosition = false;
            let attempts = 0;
            
            while (!validPosition && attempts < 50) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                
                // 检查与其他玩家的距离
                let tooClose = false;
                for (let pos of spawnPositions) {
                    const distance = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                    if (distance < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    player.x = x;
                    player.y = y;
                    spawnPositions.push({ x, y });
                    validPosition = true;
                }
                
                attempts++;
            }
        });
    }
    
    // 显示游戏界面
    function showGameInterface() {
        // 隐藏等候区
        document.getElementById('waitingRoomModal').style.display = 'none';
        
        // 显示游戏画布和控制
        document.getElementById('gameCanvas').style.display = 'block';
        
        // 隐藏大厅粒子效果
        const particlesContainer = document.querySelector('.particles');
        if (particlesContainer) {
            particlesContainer.style.display = 'none';
        }
        
        // 根据设备显示相应的控制
        if (isMobile()) {
            if (currentRoom.playerCount === 2) {
                document.getElementById('mobileControlsMultiplayer').style.display = 'block';
            } else {
                document.getElementById('mobileControlsSingle').style.display = 'block';
            }
        }
    }
    
    // 游戏主循环
    function startGameLoop() {
        const gameLoop = setInterval(() => {
            if (!battleRoyaleState.gameStarted) {
                clearInterval(gameLoop);
                return;
            }
            
            // 更新游戏状态
            updateBattleRoyale();
            
            // 渲染游戏
            renderBattleRoyale();
            
            // 检查胜利条件
            checkVictoryCondition();
            
        }, 1000 / 60); // 60 FPS
    }
    
    // 更新大乱斗游戏状态
    function updateBattleRoyale() {
        // 检查玩家碰撞
        checkPlayerCollisions();
        
        // 更新决赛圈
        updateFinalCircle();
        
        // 检查玩家是否在安全区
        checkPlayersInSafeZone();
    }
    
    // 检查玩家碰撞
    function checkPlayerCollisions() {
        for (let i = 0; i < battleRoyaleState.alivePlayers.length; i++) {
            for (let j = i + 1; j < battleRoyaleState.alivePlayers.length; j++) {
                const player1 = battleRoyaleState.alivePlayers[i];
                const player2 = battleRoyaleState.alivePlayers[j];
                
                if (!player1.alive || !player2.alive) continue;
                
                const distance = Math.sqrt(
                    (player1.x - player2.x) ** 2 + (player1.y - player2.y) ** 2
                );
                
                // 如果距离小于碰撞阈值，造成伤害
                if (distance < 30) {
                    player1.health -= 1;
                    player2.health -= 1;
                    
                    // 检查玩家是否死亡
                    if (player1.health <= 0) {
                        player1.alive = false;
                        battleRoyaleState.alivePlayers = battleRoyaleState.alivePlayers.filter(p => p.id !== player1.id);
                    }
                    if (player2.health <= 0) {
                        player2.alive = false;
                        battleRoyaleState.alivePlayers = battleRoyaleState.alivePlayers.filter(p => p.id !== player2.id);
                    }
                }
            }
        }
    }
    
    // 更新决赛圈
    function updateFinalCircle() {
        // 当只剩2个玩家时启动决赛圈
        if (battleRoyaleState.alivePlayers.length === 2 && !battleRoyaleState.finalCircleActive) {
            battleRoyaleState.finalCircleActive = true;
            battleRoyaleState.circleRadius = 200; // 放大一点的最终范围
            alert('决赛圈开始收缩！');
        }
        
        // 决赛圈收缩
        if (battleRoyaleState.finalCircleActive && battleRoyaleState.circleRadius > 50) {
            battleRoyaleState.circleRadius -= battleRoyaleState.circleSpeed;
        }
    }
    
    // 检查玩家是否在安全区
    function checkPlayersInSafeZone() {
        if (!battleRoyaleState.finalCircleActive) return;
        
        battleRoyaleState.alivePlayers.forEach(player => {
            if (!player.alive) return;
            
            const distance = Math.sqrt(
                (player.x - battleRoyaleState.circleCenter.x) ** 2 + 
                (player.y - battleRoyaleState.circleCenter.y) ** 2
            );
            
            // 如果玩家在安全区外，持续扣血
            if (distance > battleRoyaleState.circleRadius) {
                player.health -= 2;
                
                if (player.health <= 0) {
                    player.alive = false;
                    battleRoyaleState.alivePlayers = battleRoyaleState.alivePlayers.filter(p => p.id !== player.id);
                }
            }
        });
    }
    
    // 渲染大乱斗游戏
    function renderBattleRoyale() {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 绘制决赛圈
        if (battleRoyaleState.finalCircleActive) {
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(
                battleRoyaleState.circleCenter.x, 
                battleRoyaleState.circleCenter.y, 
                battleRoyaleState.circleRadius, 
                0, 
                2 * Math.PI
            );
            ctx.stroke();
        }
        
        // 绘制玩家
        battleRoyaleState.players.forEach(player => {
            if (!player.alive) return;
            
            // 绘制玩家
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x - 10, player.y - 10, 20, 20);
            
            // 绘制玩家名字
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(player.name, player.x, player.y - 15);
            
            // 绘制血量条
            const barWidth = 30;
            const barHeight = 4;
            const healthPercent = player.health / 100;
            
            ctx.fillStyle = '#333333';
            ctx.fillRect(player.x - barWidth/2, player.y + 15, barWidth, barHeight);
            
            ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : healthPercent > 0.25 ? '#f39c12' : '#e74c3c';
            ctx.fillRect(player.x - barWidth/2, player.y + 15, barWidth * healthPercent, barHeight);
        });
        
        // 显示存活玩家数
        ctx.fillStyle = '#ffffff';
        ctx.font = '16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`存活玩家: ${battleRoyaleState.alivePlayers.length}`, 10, 30);
    }
    
    // 检查胜利条件
    function checkVictoryCondition() {
        if (battleRoyaleState.alivePlayers.length === 1) {
            const winner = battleRoyaleState.alivePlayers[0];
            battleRoyaleState.gameStarted = false;
            
            setTimeout(() => {
                alert(`${winner.name}赢了！`);
                endBattleRoyaleGame();
            }, 1000);
        } else if (battleRoyaleState.alivePlayers.length === 0) {
            battleRoyaleState.gameStarted = false;
            
            setTimeout(() => {
                alert('游戏结束，没有获胜者！');
                endBattleRoyaleGame();
            }, 1000);
        }
    }
    
    // 结束大乱斗游戏
    function endBattleRoyaleGame() {
        // 重置游戏状态
        battleRoyaleState = {
            players: [],
            alivePlayers: [],
            gameStarted: false,
            finalCircleActive: false,
            circleRadius: 400,
            circleCenter: { x: 400, y: 300 },
            circleSpeed: 0.5
        };
        
        // 解散房间
        currentRoom = null;
        isRoomOwner = false;
        
        // 隐藏游戏界面
        document.getElementById('gameCanvas').style.display = 'none';
        document.getElementById('mobileControlsSingle').style.display = 'none';
        document.getElementById('mobileControlsMultiplayer').style.display = 'none';
        
        // 显示大厅粒子效果
        const particlesContainer = document.querySelector('.particles');
        if (particlesContainer) {
            particlesContainer.style.display = 'block';
        }
        
        // 显示主菜单
        showMainMenu();
    }
    
    // 显示主菜单
    function showMainMenu() {
        // 重新显示游戏按钮
        const gameButtons = document.querySelectorAll('.gameButton');
        gameButtons.forEach(btn => {
            btn.style.display = 'flex';
        });
        
        // 重新显示创建房间和广场按钮
        document.getElementById('createRoomButton').style.display = 'flex';
        document.getElementById('squareButton').style.display = 'flex';
    }
    
    // leaveRoom函数已移动到script开头
    
    // closeRoomModals函数已在script开头定义
    
    // 房间列表管理
     let roomList = [];
     let selectedRoom = null;
     let plazaUpdateInterval = null;
     
     // 广场按钮点击事件
     document.getElementById('squareButton').addEventListener('click', function() {
         showPlaza();
     });
     
     // 显示广场
     function showPlaza() {
         document.getElementById('plazaModal').style.display = 'block';
         updateRoomList();
         
         // 开始定时更新房间列表（每秒更新）
         if (plazaUpdateInterval) {
             clearInterval(plazaUpdateInterval);
         }
         plazaUpdateInterval = setInterval(updateRoomList, 1000);
     }
     
     // closePlaza函数已在script开头定义
     
     // 更新房间列表
     function updateRoomList() {
         const container = document.getElementById('roomListContainer');
         const emptyPlaza = document.getElementById('emptyPlaza');
         
         // 模拟房间数据（实际应用中应该从服务器获取）
         // 如果当前有房间，添加到列表中
         if (currentRoom && isRoomOwner) {
             roomList = [currentRoom];
         } else {
             roomList = [];
         }
         
         if (roomList.length === 0) {
             emptyPlaza.style.display = 'block';
             // 清除之前的房间列表
             const existingRooms = container.querySelectorAll('.room-item');
             existingRooms.forEach(room => room.remove());
         } else {
             emptyPlaza.style.display = 'none';
             
             // 清除之前的房间列表
             const existingRooms = container.querySelectorAll('.room-item');
             existingRooms.forEach(room => room.remove());
             
             // 添加房间到列表
             roomList.forEach((room, index) => {
                 const roomItem = document.createElement('div');
                 roomItem.className = 'room-item';
                 roomItem.style.cssText = `
                     background-color: #34495e;
                     margin: 10px 0;
                     padding: 15px;
                     border-radius: 8px;
                     border: 1px solid #3498db;
                     display: flex;
                     justify-content: space-between;
                     align-items: center;
                 `;
                 
                 // 计算剩余时间
                 const timeLeft = getRoomTimeLeft(room);
                 
                 roomItem.innerHTML = `
                     <div>
                         <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">${room.name}</div>
                         <div style="color: #3498db; cursor: pointer; text-decoration: underline;" onclick="showRoomDetail(${index})">详细说明></div>
                     </div>
                     <div style="text-align: right;">
                         <div style="margin-bottom: 5px;">👥 ${room.currentPlayers}/${room.playerCount}</div>
                         <button onclick="quickJoinRoom(${index})" style="background-color: #27ae60; color: white; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer;">加入</button>
                     </div>
                 `;
                 
                 container.appendChild(roomItem);
             });
         }
     }
     
     // 获取房间剩余时间
     function getRoomTimeLeft(room) {
         // 这里应该根据房间创建时间计算剩余时间
         // 简化处理，返回固定格式
         return "1分钟以内";
     }
     
     // 显示房间详情
     function showRoomDetail(roomIndex) {
         selectedRoom = roomList[roomIndex];
         const content = document.getElementById('roomDetailContent');
         
         content.innerHTML = `
             <h3>房间详情</h3>
             <div style="text-align: left; margin: 15px 0;">
                 <div style="margin: 8px 0;"><strong>房间名：</strong>${selectedRoom.name}</div>
                 <div style="margin: 8px 0;"><strong>模式：</strong>${selectedRoom.mode === 'battleRoyale' ? '大乱斗' : selectedRoom.mode}</div>
                 <div style="margin: 8px 0;"><strong>公开性：</strong>${selectedRoom.privacy === 'public' ? '公开' : '需密码'}</div>
                 <div style="margin: 8px 0;"><strong>人数：</strong>${selectedRoom.currentPlayers}/${selectedRoom.playerCount}</div>
                 <div style="margin: 8px 0;"><strong>解散倒计时：</strong>${getRoomTimeLeft(selectedRoom)}</div>
             </div>
         `;
         
         document.getElementById('roomDetailModal').style.display = 'block';
     }
     
     // 关闭房间详情
     function closeRoomDetail() {
         document.getElementById('roomDetailModal').style.display = 'none';
         selectedRoom = null;
     }
     
     // 快速加入房间
     function quickJoinRoom(roomIndex) {
         selectedRoom = roomList[roomIndex];
         joinRoom();
     }
     
     // 加入房间
     function joinRoom() {
         if (!selectedRoom) return;
         
         // 检查房间是否已满
         if (selectedRoom.currentPlayers >= selectedRoom.playerCount) {
             alert('房间已满！');
             return;
         }
         
         // 如果需要密码
         if (selectedRoom.privacy === 'private') {
             document.getElementById('joinPasswordModal').style.display = 'block';
             document.getElementById('joinPasswordInput').focus();
         } else {
             confirmJoinRoom();
         }
     }
     
     // 确认加入房间密码
     function confirmJoinPassword() {
         const password = document.getElementById('joinPasswordInput').value.trim();
         
         if (password !== selectedRoom.password) {
             alert('密码错误！');
             return;
         }
         
         document.getElementById('joinPasswordModal').style.display = 'none';
         document.getElementById('joinPasswordInput').value = '';
         confirmJoinRoom();
     }
     
     // 关闭密码输入弹窗
     function closeJoinPassword() {
         document.getElementById('joinPasswordModal').style.display = 'none';
         document.getElementById('joinPasswordInput').value = '';
     }
     
     // 确认加入房间
     function confirmJoinRoom() {
         // 关闭所有弹窗
         closeRoomDetail();
         closePlaza();
         
         // 加入房间
         selectedRoom.currentPlayers++;
         selectedRoom.players.push(currentUser ? currentUser.name : '玩家' + selectedRoom.currentPlayers);
         
         // 设置当前房间
         currentRoom = selectedRoom;
         isRoomOwner = false;
         
         alert('成功加入房间！');
         showWaitingRoom();
     }
    
    // 点击弹窗外部关闭
    document.getElementById('mailboxModal').addEventListener('click', function(e) {
        if (e.target === this) {
            hideMailboxModal();
        }
    });
    
    // 鼠标移动时重置自动隐藏计时器
    document.addEventListener('mousemove', function() {
        if (document.getElementById('mailboxButton').style.display !== 'none') {
            resetAutoHideTimer();
        }
    });
    
    // 如果是管理员且有未读消息，显示邮箱按钮
    if (currentUser && currentUser.id === '00000000' && mailboxMessages.filter(msg => !msg.read).length > 0) {
        showMailboxButton();
    }
    
    // 创建动态粒子效果
    createParticleSystem();
    
    // 创建动态画布效果
    createDynamicCanvas();
    
    // 为邮箱按钮添加脉冲动画
    addMailboxPulseEffect();
});

// 创建粒子系统
function createParticleSystem() {
    const particlesContainer = document.createElement('div');
    particlesContainer.className = 'particles';
    document.body.appendChild(particlesContainer);
    
    function createParticle() {
        const particle = document.createElement('div');
        particle.className = 'particle';
        
        // 随机大小和位置
        const size = Math.random() * 6 + 2;
        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.bottom = '-10px';
        
        // 随机动画延迟
        particle.style.animationDelay = Math.random() * 6 + 's';
        particle.style.animationDuration = (Math.random() * 4 + 4) + 's';
        
        particlesContainer.appendChild(particle);
        
        // 动画结束后移除粒子
        setTimeout(() => {
            if (particle.parentNode) {
                particle.parentNode.removeChild(particle);
            }
        }, 8000);
    }
    
    // 定期创建粒子
    setInterval(createParticle, 300);
}

// 为邮箱按钮添加脉冲效果
function addMailboxPulseEffect() {
    const style = document.createElement('style');
    style.textContent = `
        #mailboxButton {
            animation: mailboxPulse 2s ease-in-out infinite;
        }
        
        @keyframes mailboxPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
        }
        
        #mailboxButton:hover {
            animation: mailboxHover 0.3s ease-out;
            transform: scale(1.1) rotate(5deg);
        }
        
        @keyframes mailboxHover {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.15) rotate(-5deg); }
            100% { transform: scale(1.1) rotate(5deg); }
        }
        
        /* 按钮点击波纹效果 */
        .ripple-effect {
            position: relative;
            overflow: hidden;
        }
        
        .ripple-effect:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .ripple-effect:active:before {
            width: 300px;
            height: 300px;
        }
    `;
    document.head.appendChild(style);
    
    // 为所有按钮添加波纹效果类
    document.querySelectorAll('.gameButton, .loginButton').forEach(button => {
        button.classList.add('ripple-effect');
    });
}

// 创建动态画布效果
function createDynamicCanvas() {
    const canvas = document.getElementById('dynamicCanvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // 几何图形系统已移除
    
    // 窗口大小改变时重新调整画布
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
    
    // 几何图形动画已移除
}

</script>
